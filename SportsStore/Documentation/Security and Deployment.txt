Chapter 12: SportsStore: Security and Deployment
In the previous chapter, I added support for administering the SportsStore application, and it probably did not escape your attention that anyone could modify the product catalog if I deploy the application as it is. All they would need to know is that the administration features are availabe using the /Admin/Index and Order/List URLs. In this chapter, I am going to show you how to prevent random people from using the administration functions by password-protecting them. Once I have the security in place, I will show you how to prepare and deploy the SportsStore application into production

Securing the Admnistration Features
Authentication and authorization are provided by the ASP.NET Core Identity system, which intergrates neatly into both the ASP.NET Core platform and MVC applications. In the sections that follow, I will create a basic security setup that allows one suer, called Admin, to authenticate and acess the administration features in the application. ASP.NET Core Identity provides many more features for authenticating users and authorizing access to applications features and data, and you can find more detailed information later, where we'll look at how to create and manage user accounts, how to use roles and policies, and how to suppport authentication from third parties such as Microsoft, Google, Facebook, and Twitter. In this chapter, however, my goal is just to get enough functionality in place to prevent customers from being able to access the sensitive parts of the SportsStore application and, in doing so, give you a flavor of how authentication and authorization fit into an MVC application.

Creating the Identity Database
The ASP.NET Identity system is endlessly configurable and extensible and supports lots of options for how its user data is stored. I am going to use the most common, which is to store the data using Microsoft SQL Server accessed using Entity Framework Core.

Creating the Context Class
I need to create a database context file that will act as the bridge between the database and the Identity model objects it provides access to. I added a class file called AppIdentityDbContext.cs to the Models folder and used it to define a class.
Note: You might be used to adding packages to the project to get additional features like security working. But, with the release of ASP.NET Core 2, the NuGet packages required for Identity are already included in the project through the meta-package that was added to the SportsStore.csproj file as part of the project template.
The AppIdentityDbContext class is derived from IdentityDbContext, which provides Identity-specific features for Entity Framework Core. For the type parameter, I used the IdentityUser class, which is the built-in class used to represent users. Later we look at how to use a custom class that you can extend to add extra information about the users in your application.

Defining the Connection String
The next step is to define the connection string that will be for the database. This is done in the appsettings.json file of the SportsStore project, which follows the same format as the connection string that I defined for the product database.
Remember that the connection string has to be defined in a single unbroken line in the appsettings.json file and I shown in multiple lines because of the fixed width of a book page. The addition defines a connection string called SportStoreIdentity that specifies a LocalDB database called Identity

Configuring the Application
Like other ASP.NET Core features, Identity is configured in the Startup class. We set it up using the context class and connection string defined.
In the ConfigureServices method, I extended the Entity Framework Core configuration to register the context class and used the AddIdentity method to set up the Identity services using the built-in classes to represent users and roles. In the Configure method, I called the UseAuthentication method to set up the components that will interecept requests and responeses to implement the security policy.

Creating and Applying the Database Migration
The basic configuration is in place, and it is time to use the Entity Framework migrations feature to define the schema and apply it to the database. Open cmd and run the following command in the SportsStore project folder to create a new migration for the Identity database:
dotnet ef migrations add Initial --context AppIdentityDbContext
The important difference from previous database commands is that I have used the --context argument to specify the name of the context class associated with the database and I want to work with, which is AppIdentityDbContext. When you have multiple databases in the application, it is important to ensure that you are working with the right context class.
Once Entity Framework Core has generated the initial migrations, run the following command to create the database and run the migrations command:
dotnet ef database update --context AppIdentityDbContext
The result is a new LocalDb database called Identity that you can inspect using Visual Studio SQL server object explorer.

Defining the Seed Data
I am going to explicitly create the Admin user by seeding the databse when the application starts. I added a class file called IdentitySeedData.cs to the Models folder and defined the a static class.
This code uses the UserManager<T> class, which is provided as a service by ASP.NET Core Identity for managing users. The database is searched for the Admin user account, which is created - with the password of Secret123$ - if it is not present. Do not change the hard-coded password in this example because Identity has a validation policy that requires passwords to contain a number and range of characters. We'll see later how to change the validation settings.

Caution: Hard-Coding the details of the administrator account is often required so that  you can log into an application once it has been deployed and start administering it. When you do this, you must remember to change the password for the account you have created. We'll see later how to change password using Identity.
To ensure that the Identity database is seeded when the application starts, I added the statement down to the Configure method of the Startup class.

Applying a Basic Authorization Policy
Now that I have configured ASP.NET Core Identity. I can apply an authorization policy to the parts of the application that I want to protect. I am going to use the most basic authorization policy, which is to allow access to any authenticated user. Although this can be a useful policy in real applications as well, there are also options for creating finer-grained authorization controls as we'll see later, but since the SportsStore application has only one user, distingushing anonymous and authenticated request is sufficient.
The Authorize attribute is used to restrict access to action methods, and I use it to protect the Administrative actions of the application.
I don't want to stop unauthenticated users from accessing the other action methods in the Order controller, so I have applied the Authorize attribute onl to the List and MarkShipped methods. I want to protect all of the action methods defined by the Admin controller, and I can do this by applying the Authorize attribute to the controller class, which then applies the Authorization policy to all the action methods it contains.

Creating the Account Controller and Views
When an unauthenticated user sends a request that requires authentication, they are redirected to the /Account/Login URL, which the application can use to prompt the user for their credentials. In preparation, I added a view model to represent the user's credentials by adding a class file called LoginModel.cs to the Models/ViewModels folder and using it to define the class shown.
The Name and Password properties have been decorated with the Required attribute, which uses model validation to ensure that values have been provided. The Password property has been decorated with the UIHint attribute so that when I use the asp-for attribute on the input element in the login Razor view, the tag helper will set the type attribute to password; that way, the text entered by the user isn't visible on-screen. We'll talk about this later
Next I added a class file called AccountController.cs to the Controllers folder and used it to define the controller that will respond to the request to the /Account/Login URL.
When the user is redirected to the /Account/Login URL, the GET version of the Login action method renders the default view for the page, providing a view model object that includes the URL that the browser should be redirected to if the authenticaton request is successful.
Authentication credentials are submitted to the POST version of the Login method, which uses the UserManager<IdentityUser> and SignInManager<IdentityUser> services that have been received through the controller's constructor to authenticate the user and log them into the system. I explain how these classes work later, but for now it is enough to know that if there is an authentication failure, then I create a model validation error and render the default view; however, if authentication is successful, then I redirect the user to the URL, that they want to access before they are prompted for their credentials
Caution: In general, using client-side validation is a good idea. It offloads some of the work from your server and gives users immediate feedback about the data they are providing. However, you should not be tempted t perform authentication at the client, as this would typically involve sending valid credentials to the client so they can used to check the username and password that the user has entered, or at least trusting the client's report of whether they have successfully authenticated. Authentication should always be done at the server.
To provide the Login method with a view to render, I created the Views/Account folder and added a razor view file called Login.cshtml with the followig content.
The final step is a change to the shared adminstration layout to add a button that will log the current user out by sending a request to the Logout action. This is a useful feature that makes it easier to test the application, without which you need to clear the browsers cookies in oder to return to the unauthenticated state.

Testing the Security Policy
Everything is in place, and you can test the security policy by starting the application and requesting the /Admin/Index URL. Since you are presently unauthenticated and you are try to target the acton that requires authorization, your browser will be redirected to the /Account/Login URL. Enter Admin and Secret123$ as the name and password and submit the form. The account controller will check the credentials you provided with the seed data added to the identity database and - assuming you entered the right details - authenticate you and redirect you back to the /Account/Login URL, to whic hyou now have access.

Deploying the Application
All the features and functionality for the SportsStore application are in place, so it is time to prepare the application and deploy it into production. Lot's of hosting options are available for ASP.NET Core MVC applications, and the one that I use in this chapter is the Microsoft Azure platform, which I have chosen because it comes from Microsoft and because it offers free accounts, which means you can follow the SportsStore example all the way through, even if you don't want to use Azure for your ow projects.
Note: You will need an Azure account for this section. If you don't have one, you can create a free one at http://azure.microsoft.com

Creating the Database
The starting point is to create the database that the SportsStore application will use in production. This is something that you can do as part of the Visual Studio deployment process, but it is a chicken-and-egg situation because you need to know the connection strings for the databases before you deploy, which is the process that creates the databases.
Caution: The Azure portal changes often as Microsoft adds new features and revises existing ones. The instructions in this section were accure when I wrote them, but the required steps may have changed slightly by the time you read this. The basic approach should still be the same, but the name of data fields and the exact order of steps may require some experimentation to get the right results.
The simplest approach is to log in to http://portal.azure.com using your Azure account and create the database manually. Once you are logged in, select the SQL Databases resource category and click the Add button to create the new database.
For the first database, enter the name products, Click the Configure Required Settings link and then the Create a New Server link. Enter a new server name - which must be unique across Azure - and select a database administrator username and password. I entered the server name sportsstorecore2db, with the administrator name of sportsstoreadmin and a password of Secret123$. You will have to use a different server name, and I sugguest that you use a more robutst password. Select a location for your database; click the select button to close the options and then the Create button to create the database itself. Azure will take a few minutes to perform the creation process, after which it will appear in the SQL Database resource category.
Create another SQL server, this time entering the name identity. You can use the database server that you created a moment ago, rather than creating a new one. THe result is two SQL Server databases hosted by Azue. You will have different database server name and ideally better passwords

Opening Firewall Access for Configuration
I need to populate the database with their schemas, and the simplest way to do that is by opening Azure firewall access so that I can run the Entity Framework command from my development machine.
Select either of the database in the SQL datbase resource category,click the tools button, and then click the open in Visual Studio link. Now  click configure your Firewall link, click the Add Client IP button, and then click Save. This allows your current IP address to reach the database server and perform configuration commands (You can inspect the database schema by clicking the open in Visual Studio button, which will open Visual Studio and use the SQL Server Object Explorer to examine the database.)

Getting the Connection Strings
I will need the connection strings for the new database shortly. Azure provides this information when you click a database in the SQL database resource category through the show the database connection string link. Connection strings are provided for different development platforms, and it is the ADO.NET stirng that are required for .NET application.

Preparing the Application
I have some basic preparation to do before I can deploy the application, to make it ready for the production environment. In the section that follow, I change the way that errors are displayed and set up the production connection string for the database.

Creating the Error Controller and View
At the moment, the application is configured to use the developer-friendly error pages, which provide helpful information when a problem occurs. This is not the information that end users should see, so I added a class file called ErrorController.cs to the Controllers folder and used it to define the simple controller.
The controller defines an Error action method that renders the default view. To provide the controller with the view, I created the Views/Error folder, added a razor file called Error.cshtml and applied some markup
This kind of error page is the last resort, and it is best to keep it as simple as possible and not rely on shared views, view components, or other rich features. In this case, I have disabled shared layouts and defined a simple HTML document that explain s that there has been an error, without providing any information about what has happened.

Defining the Production Database Settings
The next step is to create a file that will provide the application with its database connection string in productio. I added a new ASP.NET configuration file called appsettings.production.json to the SportsStore project and added the content show below
Tip: The Solution Explorer nests this file inside appsetting.json  in the file listing, which you will have to explain if you want to edit the file again later.
The file is hard to read because connection strings cannot be split across multiple lines. The contents of the file duplicate the connection string seciton of the appsettings.json file but use the Azure connection stringss. (Remember to replace the username and password placeholders.) I have also set the MultipleActiveResultSets to True, which allows multiple concurrent queries and avoids common error condition that arise when performing complex LINQ queries of application data.
Note: Remove the brace characters when you insert your username and password into the connection string so that you end up with Password=MyPassword. 

Configuring the Application
Now I can change the Startup class so that the application behaves diffently when in production.
The IWebHost environment interface is used to provide information about the environment in which the application is running, such as development or production. When the hosting environment is set to Production, then ASP.NET Core will load the appsettings.production.json file and its contents to override the settings in the appsettings.json file, which means that the Entity Framework Core will connect to the Azure databases instead of LocalDB. There are a lot of options available for tailoring the configuration of an application in different environments. 
I have also commented out the statements that seed the databases, Which I explain in the "Managing Database Seeding" section.

Applying the Database Migrations
To set up the database with the schemas required for the application, open a new cmd or powershell, navigate to the project directory. Setting the environement so that the dotnet command-line tool will use the connection strings for Azure requires  setting an environment variable. If yore using cmd, then use this command to set the environement variable instead.
Run the following commands  in the SportsStore project folder to apply the migrations in the Project to the Azure database
The environment variables specifies the hosting environment that is used to obtain the connection strings to reach the databases. If these commands do not work, ensure that you have configured the Azure firewall to allow access to your development machine, and that you have copied and modified the connection string.

Managing Database Seeding
The statements we commented out earlier in the Startup class that seeded the database. We did this because the Entity Framework Core commands used in the previous section to apply the migrations to the database rely on the services set up by the Startup class, which means that, with those statements enabled, the code to seed the database would have been called before the migrations were applied, which would have resulted in an error and prevented the migrations from working. This didn't cause a problem when the databases were set up. For the Products database, this was because the SeedData.EnsurePopulated method applies the migrations before seeding the data and because I didn't add the Identity seed data to the application until after I had applied migrations to the database.
For the production environment, I want to take a different approach to seed data. For the user accounts, I am going to populate the database with the administrator account when there is a login attempt. I am going to add a feature to the administration tool for seeding the product databse so that the production system can be populated with the data for testing data or left empty for real data as required.
Note: Seeding authentication data in a production system should be done with care, and your application should use the features described later to change the password as soon as the application is deployed.

Seeding the Identity Data
The first way in changing the way that user data is seeding is to simplify the code in the IndenitySeedData class.
Rather than obtaining the UserManager<IdentityUser> service itself, the EnsurePopulated method receives the object as an argument. This allows me to intergrate the database seeding in the AccountController class.
These changes will ensure that the Identity database is seeded everytime that an AccountController object is created to handle an HTTP request. This is not ideal, of course, but there is no good way to seed a database, and this approach will ensure that the application can be administered both in production and development, albeit the cost of some additional database queries.

Seeding the Production Data
For the product data, I am going to present the administrator with a button that will seed the database when it is empty. The first step is to change the seeding code so tht it uses an interface that will allow it to access servives provided through a controller, rather than through the Startup class, I have also commented out the statement that automatically applies any pending migrations, which can cause data loss and should be used only with the greatest care in production systemls.
