Chapter 12: SportsStore: Security and Deployment
In the previous chapter, I added support for administering the SportsStore application, and it probably did not escape your attention that anyone could modify the product catalog if I deploy the application as it is. All they would need to know is that the administration features are availabe using the /Admin/Index and Order/List URLs. In this chapter, I am going to show you how to prevent random people from using the administration functions by password-protecting them. Once I have the security in place, I will show you how to prepare and deploy the SportsStore application into production

Securing the Admnistration Features
Authentication and authorization are provided by the ASP.NET Core Identity system, which intergrates neatly into both the ASP.NET Core platform and MVC applications. In the sections that follow, I will create a basic security setup that allows one suer, called Admin, to authenticate and acess the administration features in the application. ASP.NET Core Identity provides many more features for authenticating users and authorizing access to applications features and data, and you can find more detailed information later, where we'll look at how to create and manage user accounts, how to use roles and policies, and how to suppport authentication from third parties such as Microsoft, Google, Facebook, and Twitter. In this chapter, however, my goal is just to get enough functionality in place to prevent customers from being able to access the sensitive parts of the SportsStore application and, in doing so, give you a flavor of how authentication and authorization fit into an MVC application.

Creating the Identity Database
The ASP.NET Identity system is endlessly configurable and extensible and supports lots of options for how its user data is stored. I am going to use the most common, which is to store the data using Microsoft SQL Server accessed using Entity Framework Core.

Creating the Context Class
I need to create a database context file that will act as the bridge between the database and the Identity model objects it provides access to. I added a class file called AppIdentityDbContext.cs to the Models folder and used it to define a class.
Note: You might be used to adding packages to the project to get additional features like security working. But, with the release of ASP.NET Core 2, the NuGet packages required for Identity are already included in the project through the meta-package that was added to the SportsStore.csproj file as part of the project template.
The AppIdentityDbContext class is derived from IdentityDbContext, which provides Identity-specific features for Entity Framework Core. For the type parameter, I used the IdentityUser class, which is the built-in class used to represent users. Later we look at how to use a custom class that you can extend to add extra information about the users in your application.

Defining the Connection String
The next step is to define the connection string that will be for the database. This is done in the appsettings.json file of the SportsStore project, which follows the same format as the connection string that I defined for the product database.
Remember that the connection string has to be defined in a single unbroken line in the appsettings.json file and I shown in multiple lines because of the fixed width of a book page. The addition defines a connection string called SportStoreIdentity that specifies a LocalDB database called Identity

Configuring the Application
Like other ASP.NET Core features, Identity is configured in the Startup class. We set it up using the context class and connection string defined.
In the ConfigureServices method, I extended the Entity Framework Core configuration to register the context class and used the AddIdentity method to set up the Identity services using the built-in classes to represent users and roles. In the Configure method, I called the UseAuthentication method to set up the components that will interecept requests and responeses to implement the security policy.

Creating and Applying the Database Migration
The basic configuration is in place, and it is time to use the Entity Framework migrations feature to define the schema and apply it to the database. Open cmd and run the following command in the SportsStore project folder to create a new migration for the Identity database:
dotnet ef migrations add Initial --context AppIdentityDbContext
The important difference from previous database commands is that I have used the --context argument to specify the name of the context class associated with the database and I want to work with, which is AppIdentityDbContext. When you have multiple databases in the application, it is important to ensure that you are working with the right context class.
Once Entity Framework Core has generated the initial migrations, run the following command to create the database and run the migrations command:
dotnet ef database update --context AppIdentityDbContext
The result is a new LocalDb database called Identity that you can inspect using Visual Studio SQL server object explorer.

Defining the Seed Data
I am going to explicitly create the Admin user by seeding the databse when the application starts. I added a class file called IdentitySeedData.cs to the Models folder and defined the a static class.
This code uses the UserManager<T> class, which is provided as a service by ASP.NET Core Identity for managing users. The database is searched for the Admin user account, which is created - with the password of Secret123$ - if it is not present. Do not change the hard-coded password in this example because Identity has a validation policy that requires passwords to contain a number and range of characters. We'll see later how to change the validation settings.

Caution: Hard-Coding the details of the administrator account is often required so that  you can log into an application once it has been deployed and start administering it. When you do this, you must remember to change the password for the account you have created. We'll see later how to change password using Identity.
To ensure that the Identity database is seeded when the application starts, I added the statement down to the Configure method of the Startup class.

Applying a Basic Authorization Policy
Now that I have configured ASP.NET Core Identity. I can apply an authorization policy to the parts of the application that I want to protect. I am going to use the most basic authorization policy, which is to allow access to any authenticated user. Although this can be a useful policy in real applications as well, there are also options for creating finer-grained authorization controls as we'll see later, but since the SportsStore application has only one user, distingushing anonymous and authenticated request is sufficient.
The Authorize attribute is used to restrict access to action methods, and I use it to protect the Administrative actions of the application.
I don't want to stop unauthenticated users from accessing the other action methods in the Order controller, so I have applied the Authorize attribute onl to the List and MarkShipped methods. I want to protect all of the action methods defined by the Admin controller, and I can do this by applying the Authorize attribute to the controller class, which then applies the Authorization policy to all the action methods it contains.