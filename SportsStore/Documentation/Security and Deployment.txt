Chapter 12: SportsStore: Security and Deployment
In the previous chapter, I added support for administering the SportsStore application, and it probably did not escape your attention that anyone could modify the product catalog if I deploy the application as it is. All they would need to know is that the administration features are availabe using the /Admin/Index and Order/List URLs. In this chapter, I am going to show you how to prevent random people from using the administration functions by password-protecting them. Once I have the security in place, I will show you how to prepare and deploy the SportsStore application into production

Securing the Admnistration Features
Authentication and authorization are provided by the ASP.NET Core Identity system, which intergrates neatly into both the ASP.NET Core platform and MVC applications. In the sections that follow, I will create a basic security setup that allows one suer, called Admin, to authenticate and acess the administration features in the application. ASP.NET Core Identity provides many more features for authenticating users and authorizing access to applications features and data, and you can find more detailed information later, where we'll look at how to create and manage user accounts, how to use roles and policies, and how to suppport authentication from third parties such as Microsoft, Google, Facebook, and Twitter. In this chapter, however, my goal is just to get enough functionality in place to prevent customers from being able to access the sensitive parts of the SportsStore application and, in doing so, give you a flavor of how authentication and authorization fit into an MVC application.

Creating the Identity Database
The ASP.NET Identity system is endlessly configurable and extensible and supports lots of options for how its user data is stored. I am going to use the most common, which is to store the data using Microsoft SQL Server accessed using Entity Framework Core.

Creating the Context Class
I need to create a database context file that will act as the bridge between the database and the Identity model objects it provides access to. I added a class file called AppIdentityDbContext.cs to the Models folder and used it to define a class.
Note: You might be used to adding packages to the project to get additional features like security working. But, with the release of ASP.NET Core 2, the NuGet packages required for Identity are already included in the project through the meta-package that was added to the SportsStore.csproj file as part of the project template.
The AppIdentityDbContext class is derived from IdentityDbContext, which provides Identity-specific features for Entity Framework Core. For the type parameter, I used the IdentityUser class, which is the built-in class used to represent users. Later we look at how to use a custom class that you can extend to add extra information about the users in your application.

Defining the Connection String
The next step is to define the connection string that will be for the database. This is done in the appsettings.json file of the SportsStore project, which follows the same format as the connection string that I defined for the product database.
Remember that the connection string has to be defined in a single unbroken line in the appsettings.json file and I shown in multiple lines because of the fixed width of a book page. The addition defines a connection string called SportStoreIdentity that specifies a LocalDB database called Identity

Configuring the Application
Like other ASP.NET Core features, Identity is configured in the Startup class. We set it up using the context class and connection string defined.
In the ConfigureServices method, I extended the Entity Framework Core configuration to register the context class and used the AddIdentity method to set up the Identity services using the built-in classes to represent users and roles. In the Configure method, I called the UseAuthentication method to set up the components that will interecept requests and responeses to implement the security policy.

Creating and Applying the Database Migration
The basic configuration is in place, and it is time to use the Entity Framework migrations feature to define the schema and apply it to the database. Open cmd and run the following command in the SportsStore project folder to create a new migration for the Identity database:
dotnet ef migrations add Initial --context AppIdentityDbContext
The important difference from previous database commands is that I have used the --context argument to specify the name of the context class associated with the database and I want to work with, which is AppIdentityDbContext. When you have multiple databases in the application, it is important to ensure that you are working with the right context class.
Once Entity Framework Core has generated the initial migrations, run the following command to create the database and run the migrations command:
dotnet ef database update --context AppIdentityDbContext
The result is a new LocalDb database called Identity that you can inspect using Visual Studio SQL server object explorer.

Defining the Seed Data
I am going to explicitly create the Admin user by seeding the databse when the application starts. I added a class file called IdentitySeedData.cs to the Models folder and defined the a static class.
This code uses the UserManager<T> class, which is provided as a service by ASP.NET Core Identity for managing users. The database is searched for the Admin user account, which is created - with the password of Secret123$ - if it is not present. Do not change the hard-coded password in this example because Identity has a validation policy that requires passwords to contain a number and range of characters. We'll see later how to change the validation settings.

Caution: Hard-Coding the details of the administrator account is often required so that  you can log into an application once it has been deployed and start administering it. When you do this, you must remember to change the password for the account you have created. We'll see later how to change password using Identity.
To ensure that the Identity database is seeded when the application starts, I added the statement down to the Configure method of the Startup class.

Applying a Basic Authorization Policy
Now that I have configured ASP.NET Core Identity. I can apply an authorization policy to the parts of the application that I want to protect. I am going to use the most basic authorization policy, which is to allow access to any authenticated user. Although this can be a useful policy in real applications as well, there are also options for creating finer-grained authorization controls as we'll see later, but since the SportsStore application has only one user, distingushing anonymous and authenticated request is sufficient.
The Authorize attribute is used to restrict access to action methods, and I use it to protect the Administrative actions of the application.
I don't want to stop unauthenticated users from accessing the other action methods in the Order controller, so I have applied the Authorize attribute onl to the List and MarkShipped methods. I want to protect all of the action methods defined by the Admin controller, and I can do this by applying the Authorize attribute to the controller class, which then applies the Authorization policy to all the action methods it contains.

Creating the Account Controller and Views
When an unauthenticated user sends a request that requires authentication, they are redirected to the /Account/Login URL, which the application can use to prompt the user for their credentials. In preparation, I added a view model to represent the user's credentials by adding a class file called LoginModel.cs to the Models/ViewModels folder and using it to define the class shown.
The Name and Password properties have been decorated with the Required attribute, which uses model validation to ensure that values have been provided. The Password property has been decorated with the UIHint attribute so that when I use the asp-for attribute on the input element in the login Razor view, the tag helper will set the type attribute to password; that way, the text entered by the user isn't visible on-screen. We'll talk about this later
Next I added a class file called AccountController.cs to the Controllers folder and used it to define the controller that will respond to the request to the /Account/Login URL.
When the user is redirected to the /Account/Login URL, the GET version of the Login action method renders the default view for the page, providing a view model object that includes the URL that the browser should be redirected to if the authenticaton request is successful.
Authentication credentials are submitted to the POST version of the Login method, which uses the UserManager<IdentityUser> and SignInManager<IdentityUser> services that have been received through the controller's constructor to authenticate the user and log them into the system. I explain how these classes work later, but for now it is enough to know that if there is an authentication failure, then I create a model validation error and render the default view; however, if authentication is successful, then I redirect the user to the URL, that they want to access before they are prompted for their credentials
Caution: In general, using client-side validation is a good idea. It offloads some of the work from your server and gives users immediate feedback about the data they are providing. However, you should not be tempted t perform authentication at the client, as this would typically involve sending valid credentials to the client so they can used to check the username and password that the user has entered, or at least trusting the client's report of whether they have successfully authenticated. Authentication should always be done at the server.
To provide the Login method with a view to render, I created the Views/Account folder and added a razor view file called Login.cshtml with the followig content.
The final step is a change to the shared adminstration layout to add a button that will log the current user out by sending a request to the Logout action. This is a useful feature that makes it easier to test the application, without which you need to clear the browsers cookies in oder to return to the unauthenticated state.

Testing the Security Policy
Everything is in place, and you can test the security policy by starting the application and requesting the /Admin/Index URL. Since you are presently unauthenticated and you are try to target the acton that requires authorization, your browser will be redirected to the /Account/Login URL. Enter Admin and Secret123$ as the name and password and submit the form. The account controller will check the credentials you provided with the seed data added to the identity database and - assuming you entered the right details - authenticate you and redirect you back to the /Account/Login URL, to whic hyou now have access.

Deploying the Application
