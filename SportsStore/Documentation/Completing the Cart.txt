Chapter 10: SportsStore: Completing the Cart
In this chapter, I continue to build the SportsStore example app. In the previous chapter, I added the basic support for a shopping cart, and now I am going to improve on and complete the functionality

Refing the Cart Model with a Service
I defined a Cart model class in the previous chapter and demonstrated how it can be stored using session feature, allowing the user to build up a set of products for purchase. The responsibility for managing the persistence of the Cart class fell to the Cart controller, which explicitly defines method for getting and storing Cart objects. 
The problem with this approach is that I will have to duplicate the code that obtains and stores Cart objects in any component that uses them. In this section, I am going to use the service feature that sits at the heart of ASP.NET Core to simplify the way that Cart objects are managed, freeing individual components such as the Cart controller from needing to deal with the details directly.
Servives are most commonly used to hide details of how interfaces are implemented from the components that depend on them. You saw an example of this when I created a service for the IProductRepository interface, which allowed me to seamlessly replace the fake repository class with the Entity Framework Core repository. But services can be used to solve lots of other problems as well and can be used to shape and reshape an application, even when you're working with concrete classes such as Cart.

Creating a Storage-Aware Cart Class
The first step in tidying up the way that the Cart class is used will be to create a subclass that is aware of how to store itself using session state. I added a class file called SessionCart.cs to the Models folder and used it to define a class.
The SessionCart class subclasses the Cart class and overrides the AddItem, RemoveLine, and Clear methods so they call the base implementation and then store the updated state in the session using the extension methods on the ISeersion interface defined earlier on. The static GetCart method is a factory for creating SessionCart objects and providing them twith an ISession object so they can store themselves.
Getting hold of the ISession object is a little complicated. I have to obtain an instance of the IHTTpContextAccessor serive, which provides me with access to an HttpContext object that, in turn, provides me with the Issession. This indirect approach is required because the session isn't provided as a regular service.

Registering the Service.
The next step is to create a service for the Cart class. My goal is to satisfy requests for Cart objects with SessionCart objects that will seamlessly store themselves. You can see how I created the service.
The AddScoped method specifies that the same object should be used to satify related requests for Cart instances. How requests are related can be configured, but by default, it means that any Cart required by components handling the same HTTP request will receive the same object.
Rather than provide the AddScoped method with a type mapping, as I did for the repository, I have specified a lambda expression that will be invoked to satify Cart requests. The expression receives the collection of services that have been registered and passes the collection to the GetCart method of the SessionCart class. The result is that requests for the Cart services will be handled by creating SessionCart objects, which will serialize themselves as session data when they are modified.
I also added a service using the AddSingleton method, which specifies that the same object should always be used. The service I created tells MVC to use the HttpContextAccessor class when implementations of the IHttpContextAccessor interfaces are required. This service is required so I can access the current session in the SessionCart clss.

Simplifying the Cart Controller
The benefit of creating this kind of service is that it allows me to simplify the controllers where Cart objects are used. I have reworked the CartControler class to take advantage of this new service.
The CartController class indicates that it needs a cart object by declaring a constructor argument, which has allowed me to remove the method that read and write data from the session and the steps required to write updates. The result is a controller that is simpler and remains focused on its role in the application without having to worry about how Cart objects are created or persisted. And, since services are available throughout the application, any component can get hold of the user's cart using the same technique.

Completing the Cart Functionality
Now that I have introduced the Cart service, it is time to complete the cart functionality by adding two new features. The first will allow the customers to remove an item from the cart. The second feature will display a summary of the cart  at the top of the page.

Removing Items from the Cart
I already defined and tested the RemoveFromCart action method in the controller, so letting the customer remove items is just a matter of exposing this method in a view, which I am going to do by adding a Remove button in each row of the cart summary.
I added a new column to each row of the table that contains a form with hidden input elements that specify the product to be removed and the returnUrl, along with a button that submits the form. You can see the Remove buttons at work by running the application and adding items to the shopping cart. Remember that the cart already contains teh functionality to remove it, which you can test by clicking one of teh new buttons.

Adding the Cart Summary Widget
I may have a functioning cart, but there is an issue with the way it is intergrated into the interface. Customers can tell what is in their cart only by viewing the cart summary screen. And they can view the cart summary screen only by addinga new item to the cart.
To solve this problem, I am going to add a widget that summarizes the content of the cart and that can be blicked to display the cart contents throughout the application, I will do this in much the same way that I added the navigation widget - as a view component whose output I can include in the Razor shared layout.

Adding the Font Awesome Package
As part of the cart summary, I am going to display a button that allows the users to check out. Rather than display the word checkout in the button, I want to use a cart symbol. Since I have no artistic skills, I am going to use the Font Awesome package, which is an excellent set of open source icons that are intergrated into applications as fonts, where each character in the font is a different image. You can learn more about Font Awesome, including inspecting the icons that it contains at their site.
I selected the SportsStore project and clicked the Show All Items button at the of of the Solution Explorer to reveal the bower.json file. I then added the Font Awesome package to the dependencies section.
When the bower.json file is saved, Visual Studio uses Bower to download and install the Font Awesome package in www/lib/fontawesome folder.

Creating the View Component Class and View
I added a class file called CartSummaryViewComponent.cs in the Components folder and used it to define the view component.
This view component is able to take advantage of the service that I created earlier in the chapter in order to receive a Cart object as a constructor argument. The result is a simple view component class that passes on the Cart object to the View method in order to generate the fragment of HTML that will be included in the layout. To create the layout, I created the Views/Shared/Components/CartSummary folder, and added to it a Razor view file called Default.cshtml, and added some markup.
The view displays a button with the Font Awesome cart icon and, if there are items in teh cart, provides a snapshot that details the number of items and their total value. Now that I have a view component and a view, I can modify the shared layout so that the Cart summary is included in the response generateds.
You can see the cart summary by starting the application. When the cart is empty, only the checkout button is shown. If you add items to the cart, then the number of items and their combined cost are shown. With this addition, customers can know what is in their cart and have an obvious way to check out from the store.

Submitting Orders
