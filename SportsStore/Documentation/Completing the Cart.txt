Chapter 10: SportsStore: Completing the Cart
In this chapter, I continue to build the SportsStore example app. In the previous chapter, I added the basic support for a shopping cart, and now I am going to improve on and complete the functionality

Refing the Cart Model with a Service
I defined a Cart model class in the previous chapter and demonstrated how it can be stored using session feature, allowing the user to build up a set of products for purchase. The responsibility for managing the persistence of the Cart class fell to the Cart controller, which explicitly defines method for getting and storing Cart objects. 
The problem with this approach is that I will have to duplicate the code that obtains and stores Cart objects in any component that uses them. In this section, I am going to use the service feature that sits at the heart of ASP.NET Core to simplify the way that Cart objects are managed, freeing individual components such as the Cart controller from needing to deal with the details directly.
Servives are most commonly used to hide details of how interfaces are implemented from the components that depend on them. You saw an example of this when I created a service for the IProductRepository interface, which allowed me to seamlessly replace the fake repository class with the Entity Framework Core repository. But services can be used to solve lots of other problems as well and can be used to shape and reshape an application, even when you're working with concrete classes such as Cart.

Creating a Storage-Aware Cart Class
The first step in tidying up the way that the Cart class is used will be to create a subclass that is aware of how to store itself using session state. I added a class file called SessionCart.cs to the Models folder and used it to define a class.
The SessionCart class subclasses the Cart class and overrides the AddItem, RemoveLine, and Clear methods so they call the base implementation and then store the updated state in the session using the extension methods on the ISeersion interface defined earlier on. The static GetCart method is a factory for creating SessionCart objects and providing them twith an ISession object so they can store themselves.
Getting hold of the ISession object is a little complicated. I have to obtain an instance of the IHTTpContextAccessor serive, which provides me with access to an HttpContext object that, in turn, provides me with the Issession. This indirect approach is required because the session isn't provided as a regular service.

Registering the Service.
The next step is to create a service for the Cart class. My goal is to satisfy requests for Cart objects with SessionCart objects that will seamlessly store themselves. You can see how I created the service.
The AddScoped method specifies that the same object should be used to satify related requests for Cart instances. How requests are related can be configured, but by default, it means that any Cart required by components handling the same HTTP request will receive the same object.
Rather than provide the AddScoped method with a type mapping, as I did for the repository, I have specified a lambda expression that will be invoked to satify Cart requests. The expression receives the collection of services that have been registered and passes the collection to the GetCart method of the SessionCart class. The result is that requests for the Cart services will be handled by creating SessionCart objects, which will serialize themselves as session data when they are modified.
I also added a service using the AddSingleton method, which specifies that the same object should always be used. The service I created tells MVC to use the HttpContextAccessor class when implementations of the IHttpContextAccessor interfaces are required. This service is required so I can access the current session in the SessionCart clss.

Simplifying the Cart Controller
The benefit of creating this kind of service is that it allows me to simplify the controllers where Cart objects are used. I have reworked the CartControler class to take advantage of this new service.
The CartController class indicates that it needs a cart object by declaring a constructor argument, which has allowed me to remove the method that read and write data from the session and the steps required to write updates. The result is a controller that is simpler and remains focused on its role in the application without having to worry about how Cart objects are created or persisted. And, since services are available throughout the application, any component can get hold of the user's cart using the same technique.

Completing the Cart Functionality
Now that I have introduced the Cart service, it is time to complete the cart functionality by adding two new features. The first will allow the customers to remove an item from the cart. The second feature will display a summary of the cart  at the top of the page.

Removing Items from the Cart
I already defined and tested the RemoveFromCart action method in the controller, so letting the customer remove items is just a matter of exposing this method in a view, which I am going to do by adding a Remove button in each row of the cart summary.
I added a new column to each row of the table that contains a form with hidden input elements that specify the product to be removed and the returnUrl, along with a button that submits the form. You can see the Remove buttons at work by running the application and adding items to the shopping cart. Remember that the cart already contains teh functionality to remove it, which you can test by clicking one of teh new buttons.

Adding the Cart Summary Widget
I may have a functioning cart, but there is an issue with the way it is intergrated into the interface. Customers can tell what is in their cart only by viewing the cart summary screen. And they can view the cart summary screen only by addinga new item to the cart.
To solve this problem, I am going to add a widget that summarizes the content of the cart and that can be blicked to display the cart contents throughout the application, I will do this in much the same way that I added the navigation widget - as a view component whose output I can include in the Razor shared layout.

Adding the Font Awesome Package
As part of the cart summary, I am going to display a button that allows the users to check out. Rather than display the word checkout in the button, I want to use a cart symbol. Since I have no artistic skills, I am going to use the Font Awesome package, which is an excellent set of open source icons that are intergrated into applications as fonts, where each character in the font is a different image. You can learn more about Font Awesome, including inspecting the icons that it contains at their site.
I selected the SportsStore project and clicked the Show All Items button at the of of the Solution Explorer to reveal the bower.json file. I then added the Font Awesome package to the dependencies section.
When the bower.json file is saved, Visual Studio uses Bower to download and install the Font Awesome package in www/lib/fontawesome folder.

Creating the View Component Class and View
I added a class file called CartSummaryViewComponent.cs in the Components folder and used it to define the view component.
This view component is able to take advantage of the service that I created earlier in the chapter in order to receive a Cart object as a constructor argument. The result is a simple view component class that passes on the Cart object to the View method in order to generate the fragment of HTML that will be included in the layout. To create the layout, I created the Views/Shared/Components/CartSummary folder, and added to it a Razor view file called Default.cshtml, and added some markup.
The view displays a button with the Font Awesome cart icon and, if there are items in teh cart, provides a snapshot that details the number of items and their total value. Now that I have a view component and a view, I can modify the shared layout so that the Cart summary is included in the response generateds.
You can see the cart summary by starting the application. When the cart is empty, only the checkout button is shown. If you add items to the cart, then the number of items and their combined cost are shown. With this addition, customers can know what is in their cart and have an obvious way to check out from the store.

Submitting Orders
I have now reached the final customer feature in SportsStore: the ability to check out and complete an order. In the following sections, I will extent the domain model to provide support for capturing the shipping details from a user and add the application support to process those details.

Creating the Model class
I added a class file called Order.cs to the Models folder and edited it to match the content shown below. This is the class I will use to represent the shipping details for a customer.
I am adding the validation attribute from the System.ComponentModel.DataAnnotations namespace. We'll do validation later.
I also use the BindNever attribute, which prevents the user from supplying values for these properties in an HTTP request. This is a feature of model binding system; it stops MVC using value from the HTTP request to populate sensitive or important model properties.

Adding the Checkout Process
The goal is to reach the point where users are able to enter their shipping details and submit their orders. To start, I need to add a checkout button to the cart summary view.
This change generates a link that I have styled as a button and that, when clicked, calls the Checkout action method of the Order controller, which I create in the following section. You can see how this button appears.
I now need to define the Order controller. I added a class file called OrderController.cs to the Controllers folder and used it to define a class.
The Checkout method returns the default view and passes a new ShippingDetails object as the view model. To create the view, I created the Views/Order folder and added a Razor view file called Checkout.cshtml having some markup.
For each of the properties in the model, I have created a label element and an input element to capture the user input, formatted with Bootstrap. The asp-for attribute on the input element is handled by a built-in tag helper that generates the type, id, name and value attributes based on the specific model property.
You can see the effect of the new action method and view by starting the application, clicking the cart button at the top of the page, and then clicking the checkout button. You can also reach this point by requesting the /Cart/Checkout URL.

Implementing Order Processing
I will process orders by writing them to the database. Most e-commerce sites would not simply stop there, of course, and I have not provided supoort for processing credit cards or other forms of paymet. But I want to keep things focused on MVC, so a simple database entry will do.

Extending the Database
Adding a new kind of model to the database is simple once the basic plumbing that I created earlier is in place. First, I added a new property to the database context class.
This change is enough for Entity Framework Core to create a database migration that will allow Order objects to be stored in the database. To create the migration, open a new cmd, navigate to the projects folder and run appropriate commands.
The commands tells Entity Framework Core to take a new snapshot of the application data model, work out how it differs from the previous database version, and generate a new migration called Orders. The new migration will be applied automatically when the application starts because SeedData calls the Migrate method provided by Entity Framework core.

Resetting the Database
When you're making frequent changes to the model, there will come a point when your migrations and your database schema get out of sync. The easiest thing to do is delete the database and start over. However, this applies during development, of course, because you will lose any data you have stored. To delete the database, run the following command:
dotnet ef database drop --force
Once the database has been removed, run the following command from the project's folder to recreate the database and apply the migrations you have created by running the following command.
dotnet ef database update
This will reset the database so that it accurately reflects your model and allow you to return to developing your application.

Creating the Order Repository
I am going to follow the same pattern I used for the product repository to provide access to the Order objects. I added a class file called IOrderRepository.cs to the Models folder and used it to define an interface.
To implement the order repository interface, I added a class file called EFOrderRepository.cs to the Models folder and defined a class to it.
This class implements IOrderRepository using Entity Framework Core, allowing the set of Order objects that have been stored to be retrieved and allowing orders to be created or changed.

Understanding the Order Repository
There is a little extra work required to implement the repository for the orders. Entity Framework Core requires instruction to load related data if it spans multiple tables. I used the Include and ThenInclude methods to specify that when an Order object is read from the database, the collection associated with the Lines property should also be loaded along with each Product object associated with the line collection object.
This ensures that I receive all the data objects that I need without having to perform the queries and assemble data directly.
An additional step is required when I store an Order object in the database. When the user's cart data is deserialized from the session store, the JSON package creates new objects that are not known to Entity Framework Core, which then tries to write all the objects into the database. For the Product objects, this means that Entity Framework Core tries to write objects that have already been stored, which causes an error. To avoid this problem, I notify Entity Framework Core that the Objects exist already and shouldn't be stored in the database unless they are modified, as follows.
This ensures that Entity Framework Core won't try to write the deserialized Product objects that are associated with the Order object.
Next I have to register the order repository as a service in the ConfigureServices method of the Startup class.

Completing the Order Controller
To complete the OrderController class, I need to modify the constructor so that it receives the services it requires to process an order, and I need to add a new action method that will handle the HTTP form POST request when the user clicks the Complete Order button.
The Checkout action method is decorated with the HttpPost attribute, which means that it will be invoked for a POST request - in this case, when the user submits the form. Once again, I am relying on the model binding system so that I can receive the Order object, which I them complete using data from the Cart and store in the repository.
MVC checks for validation constrains that I applied to the Order class using the data annotation attributes, and any validation problems are passed to the action method through the ModelState property. I can see whether there are any problems by checking the ModelState.IsValid property. I call the ModelState.AddModelError method to register an error message if ther are no items in the Cart. I will explain how to display such error shortly, and I have much more to say about model binding and validation later.

Unit Test: Order Processing
To perform unit testing for the OrderController class, I need to test the behavior of the POST version of the Checkout method. Although the method looks short and simple, the use of MVC model binding means that there is a lot going on behind the scenes that needs to be tested.
I want to process an order only if there are items in the cart and the customer has provided valid shipping details. Under all other circumstances, the customer should be shown an error. Here is the first method, which I defined in a class file called OrderControllerTests.cs in the SportsStore.Tests project
This test ensures that I cannot checkout with an empty cart. I check this by ensuring that SaveOrder of the mock IOrderRepository implementation is never called, that the view the method returns is the default view (which will redisplay the data entered by customers and give them a chance to correct it), and that the model state being passed to the view has been marked as invalid. This may seem like a belt-and-braces set of assertions, but I need all three to be sure that I have the right behavior. The next test method works in much the same way but injects an error into the view model to simulate a problem reported by the model binder (which would happen in product when the customer enters invalid shipping details):
Having established that an empty cart or invalid details will prevent an order from being processed, I need to ensure that I process orders when appropriate, Here is the test:
