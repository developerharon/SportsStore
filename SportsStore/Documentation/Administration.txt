Chapter 11: SportsStore: Administration
In this chapter I continue to build the SportsStore application to give the side adminstrator a way of managing orders and products

Managing Orders
In the previous chapter, I added support for receiving orders from customers and storing them in a database. In this chapter, I am going to create a simple administration tool that will let me view the orders that have been received and mark them as shipped.

Enhancing the Model
The first change I need to make is to enhance the model so that I can record which orders have been shipped. I add a new property to the Order class, which is defined in the Order.cs file in the Models folder.
This iterative approach of extending and adapting the model to support different features is typicall of MVC development. In an ideal world, you would be able to completely define the model classes at the start of the project and just build the application around them, but that happens only for the simplest projects, and, in practice, iterative development is to be expected as the understanding of what is required develops and evolves.
Entity Framework Core migrations make this process easier because you don't have to manually keep the database schema synchronized to the model class by writing your own SQL commands. To update the database to reflect the addition of the Shipped propert to the Order class, open a new cmd, navigate to the project folder(which is the one that contains the Startup.cs file) and run the following command:
dotnet ef migrations add ShippedOrders
The migration will be applied automatically when the application is started as the SeedData class calls the Migrate method provided by Entity Framework Core.

Adding the Actions and Views
The functionality required to display and update the set of orders in the database is relatively simple because it builds on the features and infrastructure that I created in previously. I need to add two new action methods to the Order Controller
The List method selects all the Order objects in the repository that have a shipped value of false and passes them to the default view. This is the action method that I will use to display a list of the unshipped orders to the administrator.
The MarkShipped method will receive a POST request that specifies the ID of an order, which is used to locate the corresponding Order object from the repository so that the Shipped property can be set to true and saved.
To display the list of unshipped orders, I added a Razor view file called List.cshtml to the Views/Order folder and added some markup. A table element is used to display some of the details from each other, including details of which product have been purchased.
Each order is displayed with a Ship button that submits a form to the MarkShipped action method. I specified a different layout for the List view using the Layout property, which overrides the layout specified in the _ViewStart.cshtml file.
To add the layout, I use the MVC layout page item template to create a file called _AdminLayout.cshtml in the Views/Shared folder, and add some markup
To see and manage the orders in the application, start the application, select some products, and then check out. Then navigate to the /Order/List URL and you will see a summary of the orders you created. Click the Ship button; the database will be updated, and the list of pending orders will be empty.
Note: At the moment, there is nothing to stop customers from requesting the Order/List URL and administering their own orders. I explain how to restrict access to action method in a bit.

Adding Catalog Management
The convention for managing more complex collections of items is to present the user with two types of pages: a list page and an edit page.
Together, these pages allow a user to create, read, update and delete items in the collection. Collectively, these actions are known as CRUD. Developers need to implement CRUD so often that Visual Studio Scaffolding include scenarios for creating CRUD controllers with predefined action methods. But like all Visual Studio templates, I think it is better to learn how to use the fetures of the ASP.NET Core MVC directly.

Creating the CRUD controller
I am going to start by creating a separate controller for managing the product catalog. I added a class file called AdminController.cs to the Controllers folder and added some code.
The controller constructor declarea a dependency on the IProductRepository interface, which will be resolved when the instances are created. The controller defines a single action method Index that calls the View method to select the default view for the action, passing the set of products in the database as the view model.

Unit Test: The Index Action
