Chapter 11: SportsStore: Administration
In this chapter I continue to build the SportsStore application to give the side adminstrator a way of managing orders and products

Managing Orders
In the previous chapter, I added support for receiving orders from customers and storing them in a database. In this chapter, I am going to create a simple administration tool that will let me view the orders that have been received and mark them as shipped.

Enhancing the Model
The first change I need to make is to enhance the model so that I can record which orders have been shipped. I add a new property to the Order class, which is defined in the Order.cs file in the Models folder.
This iterative approach of extending and adapting the model to support different features is typicall of MVC development. In an ideal world, you would be able to completely define the model classes at the start of the project and just build the application around them, but that happens only for the simplest projects, and, in practice, iterative development is to be expected as the understanding of what is required develops and evolves.
Entity Framework Core migrations make this process easier because you don't have to manually keep the database schema synchronized to the model class by writing your own SQL commands. To update the database to reflect the addition of the Shipped propert to the Order class, open a new cmd, navigate to the project folder(which is the one that contains the Startup.cs file) and run the following command:
dotnet ef migrations add ShippedOrders
The migration will be applied automatically when the application is started as the SeedData class calls the Migrate method provided by Entity Framework Core.

Adding the Actions and Views
The functionality required to display and update the set of orders in the database is relatively simple because it builds on the features and infrastructure that I created in previously. I need to add two new action methods to the Order Controller
The List method selects all the Order objects in the repository that have a shipped value of false and passes them to the default view. This is the action method that I will use to display a list of the unshipped orders to the administrator.
The MarkShipped method will receive a POST request that specifies the ID of an order, which is used to locate the corresponding Order object from the repository so that the Shipped property can be set to true and saved.
To display the list of unshipped orders, I added a Razor view file called List.cshtml to the Views/Order folder and added some markup. A table element is used to display some of the details from each other, including details of which product have been purchased.
Each order is displayed with a Ship button that submits a form to the MarkShipped action method. I specified a different layout for the List view using the Layout property, which overrides the layout specified in the _ViewStart.cshtml file.
To add the layout, I use the MVC layout page item template to create a file called _AdminLayout.cshtml in the Views/Shared folder, and add some markup
To see and manage the orders in the application, start the application, select some products, and then check out. Then navigate to the /Order/List URL and you will see a summary of the orders you created. Click the Ship button; the database will be updated, and the list of pending orders will be empty.
Note: At the moment, there is nothing to stop customers from requesting the Order/List URL and administering their own orders. I explain how to restrict access to action method in a bit.

Adding Catalog Management
The convention for managing more complex collections of items is to present the user with two types of pages: a list page and an edit page.
Together, these pages allow a user to create, read, update and delete items in the collection. Collectively, these actions are known as CRUD. Developers need to implement CRUD so often that Visual Studio Scaffolding include scenarios for creating CRUD controllers with predefined action methods. But like all Visual Studio templates, I think it is better to learn how to use the fetures of the ASP.NET Core MVC directly.

Creating the CRUD controller
I am going to start by creating a separate controller for managing the product catalog. I added a class file called AdminController.cs to the Controllers folder and added some code.
The controller constructor declarea a dependency on the IProductRepository interface, which will be resolved when the instances are created. The controller defines a single action method Index that calls the View method to select the default view for the action, passing the set of products in the database as the view model.

Unit Test: The Index Action
The behavior that I care about for the Index method of the Admin Controller is that it correctly returns the Product objects that are in the repository. I can test this by creating a mock repository implementation and comparing the test data with the data returned by the action method. Here is the unit test, which I placed into a new unit test file called AdminControllerTests in the SportsStore.UnitTests project.
I added a GetViewModel method to the test to unpack the result from the action method and get the view model data. I'll be adding more tests that use this method later in the chapter.

Implementing the List View
The next step is to add a view for the Index action method of the Admin controller. I created the Views/Admin folder and added a razor file to it called Index.cshtml.
This view contains a table that has a row for each product with cells that contain the name of the product, the price and the buttons that will allow the product to be edited or deleted by sending a request to Edit and Delete actions. In addition to the table. there is an Add Product button that targets the Create action. Ill add the Edit, Delete, and Create action in the sections that follow, but you can see how the products are displayed by starting the application and requesting the /Admin/Index URL.
Tip: The Edit button is inside the form element so that the two buttons sit next to each other, working around the spacing that bootsrap applies. The Edit button will send an HTTP GET request to the server to get the current details of the product; this doesn't require a form element. However, since the Delete button will make a change to the application state, I need to use an HTTP POST request - and that does require the form element.

Editing Products
To provide create and udpate features, I will add a product-editing page like the one we sketched earlier on. These are the two parts of this job:
- Display a page that will allow the administrator to change values for the properties of a product.
- Add an action method that can process those changes when they are submitted.

Creating the Edit action method
We add this action method to the Admin controller, which will receive the HTTP request sent by the browser when the user clicks an Edit button.
This simple method finds the produt with the ID that corresponds to the productId parameter and passes it as a view model object to the View method.

Unit Test: The Edit Action Method
I want to test for two behaviours in the Edit action method. The first is that I get the product I ask for when I provide a valid ID value to make sure that I am editing the product I expected. The second behavior to test is that I do not get any product at all when I request an ID value that is not in the repository. Here are the test methods I added to the AdminControllerTests.cs class file:

Creating the Edit View
Now that I have an action method, I can create the view for it to display. I addea a razor file called Edit.cshtml to the Views/Admin folder and added the edit markup to it.
The View contains an HTML form that uses tag helpers to generate much of the content, including setting the target for the form and a elements, setting the content for the label elements, and producing the name, id, and value attributes for the input and textarea elements.
You can see the HTML producted by the view by starting the application, navigating to the Admin/Index URL, and clicking the Edit button for one of the products.
Tip: I have used a hidden input element for the ProductId property for simplicity. The value of the ProductId is generated by the database as the primary key when a new object is stored by Entity Framework core, and safely changing it can be a complex process. For most application, the simplest approach is to prevent the user form changing the value.

Updating the Product Repository
Before I can process edits, I need to enhance the product repository so that it is able to save changes. First I added a new method to the IProductRepository interface.
I can then add the new method to the Entity Framework Core implementation of the Repository, which is defined in the EFProductRepository.cs file.
The implementation of the SaveChanges method adds a product to the repository if the ProductId is 0; otherwise, it applies any changes to the existing entry in the database.
I do not want to go into details of Entity Framework Core because, as I explained earlier, it is a topic in itself and not part of ASP.NET Core MVC. But there is something in the SaveProduct method that has a bearing on the design of the MVC application.
I know I need to perform an update when I receive a Product parameter that has a ProductId that is not zero. I do this by getting a Product object from the repository with the same ProductId and updating each of the properties so they match the parameter object.
I can do this because Entity Framework Core keeps track of the objects that it creates from the database. The object passed to the SaveChanges method is created by MVC model binding feature, which means that Entity Framework Core does not know anything about the new Product object and will not apply an update to the database when it is modified. There are lots of ways of resolving this issue, and I have taken the simplest one, which is to locate the corresponding object that Entity Framework does know about and update it explicitly.
The addition of a new method in the IProductRepository interface has broken the fake repository class - FakeProductRepository - that I created earlier. We used it to kick-start the development process and demonstrate how services can be used to seamlessly replace interface implementation without needing to modify the components that rely on them. I don't need the fake repository any further, so we remove the interfae from the class declaration so that I don't have to keep modifying the class as I add repository features.

Handling Edit POST Requests
I am ready to implement an overload of the Edit action method in the Admin controller that will handle POST request when the administrator clicks the Save button.
I Check that the Model binding process has been able to validate the data submitted by the user by reading the value of the ModelState.IsValid property. If everything is OK, I save the changes to the repository and redirect the user to the Index action so they can see the modified list of products. If there is a problem with the data, I render the default view again so that the user can make corrections.
After I have saved the changes in the repository, I store a message using the temp data feature, which is part of the ASP.NET Core session state feature. This is a key value dictionary similarly to the session data and view bag features we've used previously, The key difference from session data is that temp data persists until it is read.
I cannot use ViewBag in this feature because ViewBag passes data between the controller and view and it cannot hold data for longer thatn the current HTTP request. When an edit succeeds, the browser is redirected to a new URL, so the ViewBag data is lost. I could use the session data feature but then the message would be persistent until I explicity remove it, which I would rather not have to do.
So, the temp data feature is the perfect fit. The data is restricted to a single user's session (so that users do not see each other's TempData) and will persist long enough for me to read it. I will read the data in the view rendered by the action method to which I have redirected the user, which I define in the next session.

Unit Test: Edit Submissions
For the POST-processing Edit action method, I need to make sure that valid updates to the Product object, which is received as the methods argument, are passed to the product repository to be saved. I also want to check that invalid updates (where a model validation error exists) are not passed to the repository. Here are the test methods, which I added to the AdminControllerTests.cs file

Displaying a Confirmation Message
I am going to deal with the message I stored using TempData in the _AdminLayou.cshtml layout file. By handing the message in the template, I can create message in any view that uses the template without needing to create additional Razor expressions.
Tip: The benefit of dealing with the message in the template like this is that users will see it displayed on whatever page is rendered after they have saved changed. At the moment, I return them to the list products, but I could change the workflow to render some other view, and the user will still see the message (as long as teh enxt view also uses the same layout).
I now have all the pieces in place to edit the product. To see how it all works out, start the appllication, navigate to the /Admin/Index URL, click the Edit button, and make changes. Click the Save button. You will be redirected to teh /Admin/Index URL, and the TempData message will be displayed. The message will disappear if you reload the product list because TempData is deleted when it is read. That is convenient since I do not want old messages hanging around.

Adding Model Validation
I have reached the point where I need to add validation rules to the model classes. At the moment, the administrator could enter negative prices or blank description, and SportsStore would happily store that data in the database. Whether or not the bad data would be successfully persisted would depend on whether it conformed to the constraints in the SQL tables created by Entity Framework Core, and that is not enough protection for most applications. To guard against bad data values, I decorated the properties of the Product class with attributes, just as I did for the Order class.
For the checkout form, we used a tag helper to display a summary of validation errors at the top of the form. For this example, I am going to use a similar approach, but I am going to display error messages next to individual form elements in the Edit view.
When applied to a span element, the asp-validation-for attribute applies a tag helper that will add a validation error message for the specified property if there are any validation problems.
The tag helper will insert an error message into the span element and add the element into the input-validation-error class, which makes it easy to apply CSS style to error message elements.
The CSS style I defined selects elements that are members of the input-validation-error class and applies a red border and background color.
Tip:  Explicitly setting styles when using a CSS library like Bootstrap can cause inconsistencies when content themes are applied. Later, I show an alternative approach that uses JavaScript code to apply Bootstrap classes to elements with validation errors, which keeps everything consistent but is also more complex.
You can apply the validation message tag helpers anywhere in the view, but it is conventional (and sensible) to put it somewhere near the problem element to give the user some context. You can see the results by running the application, editing a product and submiting invalid data.

Enabling Client-Side Validation
Currently, data validation is applied only when the administration user submits edits to the server, but most users expect immediate feedback if there are problems with the data they have entered. This is why developers often want to perform client-side validation, where the data is checked in the browser using JavaScript. MVC applications can perform client-side validation based on the data annotations I applied to the domain model class.
The first step is to add the JavaScript libraries that provide the client-side feature to the application, which is done in the bower.json file.
Client-side validation is built on top of the popular jQuery library, which simplifies working with the  browser's DOM API. The next step is to add the JavaScript files to the layout so they are loaded when the SportsStore administration features are used.
Enabling client-side validation doesn't cause any visual change, but the constraints specified by the attributes applied to the C# model class are enforced by the browser, preventing the user from submitting the form with bad data and providing immediate feedback when there is a problem.

Creating New Products
Next, I will implement the Create action method, which is the one specified by the Add Product link in the main product list page. This will allow the administrator to add new items to the product catalog. Adding the ability to create new products will require one small addition to the application. This is a great example of the power and flexibiltiy of a well-structure MVC application. First, add the Create method to the Admin controller.
The Create method does not render its default view. Instead, it specifies that the Edit view should be used. It is perfectly acceptable for one action method to use a view that is usually associated with another view. In this case, I provide a new Product as the view model so that the Edit view is populated with empty fields.
Note: I have not added a unit test for this action method. Doing so would only be testing the ASP.NET Core MVC ability to process the result from the action method result, which is something you can take for granted (Tests are not usually written for framework features unless you suspect ther is a defect).
That is the only change that is required because the Edit action method is already  set up to receive Product objects from the model binding system and store them in the database. You can test this functionality by starting the application, navigate to /Admin/Index, clicking the Add Product button, and populating and submitting the form. The details you specify in the form will be used to create a new product in the database, which will then appear in the list.

Deleting Products
Addin