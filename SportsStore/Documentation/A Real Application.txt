Chapter 8: SportsStore: A real Application

My application, called SportsStore, will follow the classic approach taken by online stores everywhere. I will create an online product catalog that customers can browse by category and page, a shopping cart where users can add and remove products, and a checkout where customers can enter their shipping details. I will also create an administration area that includes create, read, update, and delete (CRUD) facilities for managing the catalog, and I will protect it so that only logged-in administrators can make changes. 
My goal in this branch, and those that I will add is to give you a sense of what real MVC development is like by creating a realistic an example as possible. I want to focus on ASP.NET Core MVC, of course, so I have simplified the integration with external systems, such as the database, and omitted others entirely, such as payment processing. 
You might find the going a little show as I build up the levels of infrastructure I need, but the initial investment in an MVC application pays dividends, resulting in maintainable, extensible, well-structured code with excellent support for unit testing.
Most of the MVC features I use for the SportsStore application have their own chapters. 
I will call out each step needed to build the application so that you can see how the MVC features fit together. You should pay particular attention when I create views. You will get some odd results if you do not follow the examples closely.

Configuring the Application
The Startup class is resposnsible for configuring the ASP.NET Core application.
The ConfigureServices method is used to set up shared objects that can be used throughtout the application through the dependency injection feature. The AddMvc method that I called in the ConfigureServices method is an extension that sets up the shared objects used in the MVC applications.
The Configure method is used to set up the features that receive and process HTTP requests. Each method that I called in the Configure method is an extension method that sets up an HTTP request processor.

Next, I need to configure the application for Razor views.
The @using statement will allow me to use the types in the SportsStore.Models namespace in views without needing to refer to the namespace. The @addTagHelper statement enables the built-in tag helpers, which I use later to create HTML elements that reflect the configuration of the SportsStore application.

Checking and Running the Application
The application and unit test projects are created and configured and ready for development. 

Starting the Domain Model
All projects start with the domain model, which is the heart of an MVC application. Since this is an e-commerce application, the most obvious model I need is for a product.

Creating a Repository
I need some way of getting Product objects from a database. The models included the logic for storing and retrieving the data from the persistent data store. I won't worry about how I am going to implement data persistence for the moment, but I will start the process of defining an interface for it. 
This interface uses IQuearyable<T> to allow a caller to obtain a sequence of Product objects. The IQueryable<T> interface is derived from the more familiar IEnumerable<T> interface and represents a collection of objects that can be queried, such as those managed by a database.
A class that depends on the IProductRepository interface can obtain Product object without needing to know the details of how they are stored or how the implementation class will deliver them.

Understanding IEnumerable<T> and IQueryable<T> Interfaces
The IQueryable<T> interface is useful because it allows a collection of objects to be queried efficiently. It allows us to ask the database just the objects the we require using the standard LINQ statements and without needing to know what database server stores that data and how it processes the query. Without the IQueryable<T> interface, I would have to retrieve all of the Product objects from the database and then discard the ones I don't want, which becomes an expensive operation as the amount of data used by the application increases. It is for  this reason that we use the latter in database repository interfaces and classes.
However, care must be taken when using it because each time the collection of objects is enumerated, the query will be evaluated again, which means that a new query will be sent to the database. The can undermine the efficiency gains of using it. In such situation, you can convert the interface to a more predictable form using the ToList or ToArray extension methods.

Creating a Fake Repository
Now that I have defined an interface, I could Implement the persistence mechanism and hook it up to a database, but I want to add some other parts of the application first. To do this, I am going to create a fake implementation of the IproductRepository interface that will stand until I return to the topic of data storage. To create the fake repository, I addded a class file called FakeProductRepository.cs to the models folder.
The class implements the IProductRepository interface by returning a fixed collection of Product objects as the values of the Products property. The AsQueryable method is used to convert the fixed collection of objects to an IQueryable<Product>, which is required to implement the IProductRepository interface that  allows me to create a compatible fake repository without having to deal with real queries.

Register the Repository Service
MVC empasizes the use of loosely coupled components, which means you can change in one part of the application without having to make corresponding changes else where. This approach categorizes part of the application as services, which provide features that other parts of the applications use. The class that provides a service can then be altered or replaced without requiring changes in the classes that use it.
I want to create a repository service which allows controllers to get objects that implement the IProductRepository interface without knowing which class is being used. This will allow me to start developing the application using the simple class that I created and then replace it with a real repository later without having to make changes in all of the classes  that need access to the repository. Services are registered in the ConfigureServices method of the Startup class.
The statement I added tell ASP.NET Core that when a component such as the controller needs an implementation of the IProductRepository interface, it should receive an instance of FakeProductRepository class. The AddTransient method specifies that a new FakeProductRepository object should be created each time the IProductRepository interface is needed. 

Displaying a List of Products
I could spend the rest of this chapter building out the domain model and the repository and not touch the rest of the application at all. I am going to create a controller and an action method that can display details of the products in the repository. For the moment, this will be for only the data in the fake repository, but I will sort that out later. I will also set up initial routing configuration so that MVC knows how to map requests for the application to the controller I create.
When MVC needs to create a new instance of the ProductController class to handle an HTTP request, it will inspect the constructor and see that it requires an object that implements the IProductRepository interface. To determine what implementation class should be used, MVC consults the configuration in the Startup class, which tells it that FakeRepository should be used and that a new instance should be created everytime. MVC creates a new FakeRepository object and uses it to invoke the product controller constructor in order to create the controller object that will process the HTTP request. 
This is known as dependency injection, and its approach that allows controllers contructor to access the application's using an interface without having any need to know which implementation class has been configured. Later, we'll replace the fake repository with the real one, and dependency injection means that the controller will continue to work without changes. 
Calling the View method like this (without specifying a view name) tells MVC to render the default view for the action method. Passing the collection of product objects from the repository to the View method provides the framework with the data with which to populate the Models object in a strongly typed view.

Adding and Configuring the View
I need to create a view to present the content to the user, but there are some preparatory steps required that will make writing the view simpler. The first is to create a shared layout that will define common content that will be inlcuded in all HTML responses sent to clients. Shared layouts are a useful way of ensuring that the views are consistent and contain important JavaScript files and CSS stylesheets.
Next we configure the application so that the layout is applied by default. This is done by adding a View Start file.
Now we add the view that will be displayed when the List action method is used to handle a request. Views/Product folder
The @model expression at the top of the file specifies that the view will receive a sequence of Product objects from the action method as it model data. I use a @foreach expression to work through the sequence and generate a simple set of HTML elements for each Product object that is received.
This view doesn't know where the product objects came from, how they were obtained, or whether they represent all of the products known to the application. Instead, the view deals onl with how the details of each Product is diplayed using HTML elements, which is consistent with the separation of concerns.
the price.ToString("c") renders numerical values as currency according to the culture settings that are in effect on your server. 

Setting the Default Route
I need to tell MVC that it should send requests that arrive for the root URL of my application to the List action method in the ProductController class. I do this by editing the statement in the Startup class that sets up the MVC classes that handle HTTP requests. 
The Configure method of the Startup class is used to set up the request pipeline, which consist of classes (known as middleware) that will inspect HTTP requests and generate response. The UseMvc method sets up the MVC middleware, one one of the configuration options is the scheme that will be used to map URLs to controllers and action methods. 
Notice that I have set the name of the controller to be Product. This is part of the MVC naming conventions, in which the controller classes names generally end in Controller but you omit this part of the name when referring to the class. 

Running the Application
All the basics are in place. I have a controller with an action method that MVC will use when the default URL for the application is requuired. MVC will create an instance of the FakeRepository class and use it to create a new controller object to handle the request. The fake repository will provide the controller with some simple test data, which its action method passes to the Razor view so that the HTML response to the browser will inlcude details for each Product object. When generating the HTML response, MVC will combine the data from the view selected by the action method with the content from the shared layout, producing a complete HTML document that the browser can parse and display. 
This is the typical pattern of development for ASP.NET Core MVC. An initial investment of time setting everything up is necessary, and then the basic feature of the application snaps together quickly.


Preparing a Database
I can display a simple view that contains details of the products, but it uses the test data that the fake repository contains. Before I can implement a new repository with real data, I need to set up a database and populate it with some data. 
I am going to use SQL server as the database, and I will access the database using the Entity Framework Core (EF Core), which is the Microsofts .NET object-relational mapping (ORM) framework. An ORM framework presents the tables, columns, and rows of a relational database through regular C# objects.
Note: This is an area where you can choose from a wide range of tools and technologies. Not only are there different relational database available, but you can also work with object repositories, document stores, and some esoteric alternatives. There are other .NET ORM frameworks as well, each of which take a slightly different approach; these variations may give you a better fit for your projects. 
I am using Entity Framework Core for several reasons; it is simple to get working, the intergration with LINQ is first-rate, and it works nicely with ASP.NET Core MVC. 
A nice feature of SQL Server is LocalDb, wich is an administration-free implementation of the basic SQL Server features specifically designed for developers. Using this feature, I can skip the process of setting up a database while I build my project and then deploy to a full SQL Server instance later. Most MVC applications are deployed to hosted environments that are run by professional administrators, so teh LocalDB feature means that database configuration can be left in the hands of DBA, and developers can get on with coding.

Installing the Entity Framework Core Tools Package
The main EF Core functionality is added to the project by default. We need to add NuGet package to give us command-line tools that are used to create the classes that prepare database to store the application data, known as migrations. You must install this package by editing the file. This type of package cannot be added using the NuGet Package Manager or teh dotnet command-line tools.

Creating the Database Classes
The database context class is the bridge between the application and Entity Framework Core and provides access to the application's data using model objects.
The DbContext base class provides access to the EF Core's underlying functionality and the Products property will provide access to the Products objects in the database.
The ApplicationDbContext class is derived from DbContext and add the properties that will be used to read and write the application's data. There is only one property at the moment, which will provide access to the Product objects.

Creating the Repository Class
It may not seem like it at the moment, but most of the work required to set up the database is complete. The next step is to create a class that implements the IProduct repository interface and gets its data using EF Core.
I'll add functionality as I add features to the application, but for the moment, the repository implementation just maps the Products property defined by teh IProductRepository interface onto the Products property defined by the ApplicationDbContext class. The Products property in the context class returns a DbSet<Product> object, which implements the IQueryable<T> interface and makes it easy to implement the IProductRepository interface when using EF Core. This ensures that queries to the database will retrieve only the objects that are required.

Defining the Connection String
A connection string specifies the location and name of the database and provides configuration settings for how the application should connect to the database server. Connection strings are stored in a JSON File called appsettings.json
Connection strings must be expressed as a single unbroken line. The value of the connection string specifies that the LocalDB feature should be used for a database called SportsStore.

Configuring the Application
The next steps are to read the connection string and to configure the application to use it to connect to the database. The job of reading the JSON file is handled by the Program class.
The constructor I added to the Startup class receives the configuration data loaded from the appsettings.json file, which is presented through an object that implements the IConfiguration interface. The constructor assigns the IConfiguration object to a property called Configuration so that it can be used by the rest of the Startup class.
We then set up EF Core with the Configure services method.
The AddDbContext extension method sets up the services provided by EF Core for the database context class. Many of the methods used in the Startup class allow servies and middleware features to be configured using options arguments and the arguments to the AddDbContext method is a lambda expression that receives an options object that configures the databasr for the context class. In this case, we configure the database with the UseSqlServer method and specified the connection string, which is obtained from the Configuration property. The next change was to replace the fake repository with the real one.
The components in the application that use the IProductRepository interface, which is just the Product controller at the moment, will receive an EFProductRepository object when they are created, which will provide them with access to the data in the database. The effect is that the fake data will be seamlessly replaced by the real data in the database without having to change the ProductController class.

Disabling Scope Verification
Using Entity Framework Core requires a configuration change to the dependency injection feature. The Program class is responsible for starting and configuring ASP.NET Core before handling control to the Startup class. Without this change an exception will be thrown when you try to create the database scheme in the next section.

Creating the Database Migration
Entity Framework Core is able to generate the schema for the database using the model classes through a feature called migrations. When you prepare a migration, EF Core creates a C# class that contains the SQL commands required to prepare the database. If you need to modify your model classes, then you can create a new migration that contains the SQL commands required to reflect the changes. In this way, you don't have to worry about manually writing and testing SQL commands and can just focus on the C# model class in the application.
EF Core commands are performed from the command line. Always remember to navigate to the folder that contains the Statup.cs and appsettings.json files, and run the migrations commands.
EF Core stores its migration classes in the Migrations folder in Visual Studio solution. One of the file names will be a timestamp follwed by _Initial.cs, and this is the class that will be used to create the initial schema for the database. If you examine the contents of the file, you can see how the Product model class has been used to create the schema.

Creating the Seed Data
To populate the database and provide some sample data. I added a class file called SeedData.cs to the Models folder and defined a class.
The static EnsurePopulated method receives an IApplicationBuilder argument, which is the interface used in the Configure method of the startup class to register middleware components to handle HTTP requests, and this is where I will ensure that the database has content.
The EnsurePopulated method obtains an ApplicationDbContext object through the IApplicationBuilder interface and calls the Database.Migrate method to ensure that the migrations has been applied, which means that the database will be created and prepared so that it can store Product objects. Next, the number of Product objects in the database is checked. If there are no objects in the database, then the database is populated using a collection of Product objects using the AddRange method and then written to the database using the SaveChanges method.
The final change is to seed the database when the application starts, which I have done by adding a call to the EnsurePopulated method from the Startup class.
Start the application, and the database will be created and seeded,and used to provided the application with its data.
When the browser requests the default URL for the application, the application configuration tells MVC that it needs to create a Product controller to handle the request. Creating a new Product controller means invoking the ProductController contructor, which requires an object that implements the IProductRepository interface, and the new configuration tells MVC that an EFProductRepository object should be created and used for this. The EFProductRepository object taps into the Entity Framework Core functionality that loads data from SQL Server and converts it into Product objects. All of this is hidden from the ProductController class, which just receives an object that implements the IProductRepository interface and works with the data it provides. The result is that the browser window shows the sample data in the database.
This approach to getting EF Core to present a SQL Server database as a series of model objects is simple and easy to work with, and it allows me to keep my focus on ASP.NET Core MVC. I am skipping over a lot of the details in how EF Core operates and the huge number of configuration options that are available. I like EF Core a lot and I recommend that you spend sometime getting to know it in details.

Adding Pagination
You can see that the List.cshtml view displays the products in the database on a single page. In this section, I will add support for pagination so that the view displays a smaller number of products on a page and the user can move from page to page to view the overall catalog. To do this, I am going to add a parameter to the List method in the Product controller.
The PageSize field specifies that I want four products per page. I have added an optional parameter to the List method, which means that if I call the method without a parameter, my call is treated as though I had supplied the value speecified in the parameter definition. The effect is that the action method displays the first page of products when MVC invokes it without an argument. Within the body of the action method, I get the Product objects, order them by primary key, skips over the products that occur before the start of the current page, and take the number of products specified by the PageSize field.

Unit Test: Pagination.
I can unit test the pagination feature by creating a mock repository, injecting it into the contructor of the ProductController class, and then calling the List method to request a specific paage. I can then compare the Product objects I get with what I would expect from the test data in the mock implementation.
It is a little awkward to get the data returned from the action method. The result is a ViewResult object, and I have to cast the value of its viewData.Model property to the expected data type. I explain the different result types that can be returned by action methods and how to work with them later.

Displaying Page Links
If you run the application, you will see that there are now four items shown on the page. If you want to view another page, you can append query string parameters to the end of the URL.
You will need to change the port part of the URL to match whatever port has been assigned to your project. Using these query strings, you can navigate through the catalog of products.
There is no way for customers to figure out that these query string parameters exist, and even if there were, they are not going to want to navigate this way. Instead, I need to render some page links at the buttom of each list of products so that customers can navigate between pages. To do this, I am going to create a tag helper, which generates the HTML markup for the links I require.

Adding the View Model
To support the tag helper, I am going to pass information to the view about the number of pages available, the current page, and the total number of products in the repository. The easiest way to do this is to create a view model class, which is used specifically to pass data between a controller and a view. I created the Models/ViewModels folder in the SportsStore project and added to it a class file called PagingInfo.cs defined in it.