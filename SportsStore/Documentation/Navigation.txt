Chapter 9: Navigation
In this chapter, I continue to build out the SportsStore example app. In this chapter, I add support for navigating around the application and start building the shopping cart.

Adding Navigation Controls
The SportsStore application will be more useful if customers can navigate products by category. I will do this in three phases.
- Enhance the List action model in the ProductController class so that it is able to filter the Product objects in the repository.
- Revist and enhance the URL scheme
- Create a category list that will go into the sidebar of the site, highlighting the current category and linking to others

Filtering the Product List
I am going to start by enhancing the view model class, ProductsListViewModel, which I added to the SportsStore project in the previous chapter. I need to communicate the current category to the view in order to render the sidebar, and this is a good place to start as any. 
I added a property called CurrentCategory. The next step is to update the ProductController so that the List action method will filter Product objects by category and use the new property I added to the view model to indicate which category has been selected.
I made three changes to the action method. First, I added a parameter called category. This category parameter is used by the second change in the listing, which is an enhancement to the LINQ query: if category is not null, only those Product objects with a matching Category property are selected. The last change is to set the value of the CurrentCategory property I added to the ProductsListViewModel class. However, these changes mean that the value of PagingInfo.TotalItems is incorrectly calculated because it doesn't take the category filter into account. I will fix this in a while.

Unit Test: Updating Existing Unit Tests
I changed the signature of the List action method, which will prevent some of the existing unit test methods from compiling. To address this, I need to pass null as the first parameter to the LIst method in those unit tests that work with the controller. For example, in the Can_Paginate test in the ProductControllerTests.cs file, the action section of the unit test becomes as follow.
By using null for the category argument, I receive all the Product objects that the controller gets from the repository, which is the same situation I had before adding the new parameter. I need to make the same changes to the Can_Send_Pagination_View_Model test.
Keeping your unit tests synchronized with your code changes quickly becomes second nature when you get into the testing mind-set.
To see the effect of the category filtering, start the application and select a category using the following query string, changing the port to match the one that Visual Studio assigned for your project(and taking care to use an upper case S for Soccer):
You will see only the Products in the Soccer category.
Obviously, users won't want to navigate to categories using URLs, but you can see how small changes can have big impact in an MVC application once the basic structure is in place.

Unit Test: Category Filtering
I need a unit test to properly test the category filtering function to ensure that the filter can correctly generate products in a specified category. Here is the test method I added to the ProductControllerTests tests.
This test creates a mock repository containig Product objects that belong to a range of categories. Once specific category is requested using the action method, and the results are checked to ensure that the result are the right objects in the right order.

Refining the URL Scheme
No one wants to see or use ugly URLs such as /?category=Soccer. To address this, I am going to change the routing configuration in the Configure method of the Startup class to create a more useful set of URLs.
Caution: It is important to add the new routes in the specific order. Routes are applied in the order in which they are defined, and you will get some odd effects if you change the order.
The ASP.NET Core routing system is used by MVC to handle incoming requests from clients, but it also generates outgoing URLs that conform to the URL scheme and that can be embedded in web pages. By using the routing system both to handle incoming requests and to generate outgoing URLs, I can ensure that all the URLs in the application are consistent.
The IUrlHelper interface provides access to the URL-generating functionality. I used this interface and the Action method it defined in the tag helper I created in the previous chapter. Now that I want to start generating more complex URLs, I need a way to receive additional information from the view without having to add extra properties to the tag helper class. Fortunately, tag helpers have a nice feature that allows properties with a common prefix to be received altogether in a single collection. 
Decorating a tag helper property with the HtmlAttributeName attribute allows me to specify a prefix for attribute names on the ellement, which in this case will be page-url- The vaalue of any attribute whose name begins with this prefix will be added to the dictionary that is assigned to the PageUrlValues property, which is then passed to the IUrlHelper.Action method to generate the URL for the href attribute of the a elements that the tag helper produces.
We then have to add a new attribute to the div element that is processed by the tag helper, specifying the category that will be used to generate the URL. I have added only one new attribute to the view, but any attribute with the same prefix would be added to the dictionary.
Prior to this change, the links generated for pagination links we wrong.
If the user clicked a page link like this, the category filter would be lost, and the application would present a page containing the products from all categories. By adding the current category, taken from the view model, I generate better URLs.
When the user clicks such kind of links, the current category will be passed to the List action method, and the filtering will be preserved. After you have made this change, you can visit a URL such as /chess or /soccer and you will see that the link at the bottom of the page correctly includes the category.

Building a Category Navigation Menu
I need to provide customers with a way to select a category that does not involve typing in URLs. This means presenting them with a list of the categories available and indicating which, if any, is currently selected. As I build out the application, I will use this list of categories in more than one controller, so I need something that is self contained and reusable.
ASP.NET Core MVC has the concept of view component, which is perfect for creating items such as a reusable navigation control. A view component is a C# class that provides a small amount of reusable application logic with the ability to select and display Razor partial views. I describe view components later in details.
In this case, I will create a view component that renders the navigation menu and intergrates it into the application by invoking the component from the shared layout. This approach gives me a regular C# class that can contain whatever application logic I need and that can be unit tested like any other class. It is a nice way of creating small segments of an application while preserving the overall MVC approach.

Creating the Navigation View Component
I created a folder called components, which is the conventional home of view components, and added to it a class called NavigationMenuViewComponentt.cs, which I used to define a class.
The view component's Invoke method is called when the component is used in a Razor view, and the result of the invoke method is inserted into the HTML sent to the browser. I have started with a simple view component that returns a string, but I'll replace this with dynamic HTML content shortly.
I want the category list to appear on all pages, so I am going to use the view component in the shared layout rather than in a specific view. Within a view, view components are used through the @await Component.InvokeAsync expression.
I removed the placeholder text and replaced it with a call to the Component.InvokeAsync method. The argument to this method is the name of the componnet class, omiting the ViewComponent part of the class name, such that NavigationMenu specifies the NavigationMenuViewComponent class. If you run the application, you will see that the output from the Invoke method is included in the HTML sent to the browser.

Generating Category List
I can now return to the navigation view controller and generate a real set of categories. I could build the HTML for the categories programmatically, as I did for the page tag helper, but one of the benefits of working with view components is they can render Razor partial views. That means I can use the view component to generate the list of components and then use the more expressive Razor syntax to render the HTML that will display them. The first step is to update the view component.
The constructor defined defines an IProductRepository argument. When MVC needs to create an instance of the view component class, it will note the need to provide this argument and inspect the configuration in the Startup class to determine which implementation object should be used. This is the same dependency injection feature we talked about earlier and it has the same effect, which is to allow the view component to access data without knowing which repository implementation will be used.
In the Invoke method, I use LINQ to select and order the set of categories in the repository and pass them as the arguments to the View method, which render the default Razor partial view, details of which are returned from the method using an IViewComponentResult object, a process described later in more details.

Unit Test: Generating the Category List
The unit test for my ability to produce a category list is relatively simple. The goal is to create a list that is sorted in aplhabetical order and contains no duplicates, and the simplest way to do this is to supply some test data that does have duplicate categories and that is not in order, pass this to the tag helper class, and assert that the data has been properly cleaned up. Here is the unit test, which I defined in a new class file called NavigationMenuViewComponentTests.cs in the SportsStore.Tests project.
I created a mock repository implementation that contains repeating categories and categories that are not in order. I assert that the duplicates are removed and that alphabetical ordering is imposed.

Creating the View
