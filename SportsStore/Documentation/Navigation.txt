Chapter 9: Navigation
In this chapter, I continue to build out the SportsStore example app. In this chapter, I add support for navigating around the application and start building the shopping cart.

Adding Navigation Controls
The SportsStore application will be more useful if customers can navigate products by category. I will do this in three phases.
- Enhance the List action model in the ProductController class so that it is able to filter the Product objects in the repository.
- Revist and enhance the URL scheme
- Create a category list that will go into the sidebar of the site, highlighting the current category and linking to others

Filtering the Product List
I am going to start by enhancing the view model class, ProductsListViewModel, which I added to the SportsStore project in the previous chapter. I need to communicate the current category to the view in order to render the sidebar, and this is a good place to start as any. 
I added a property called CurrentCategory. The next step is to update the ProductController so that the List action method will filter Product objects by category and use the new property I added to the view model to indicate which category has been selected.
I made three changes to the action method. First, I added a parameter called category. This category parameter is used by the second change in the listing, which is an enhancement to the LINQ query: if category is not null, only those Product objects with a matching Category property are selected. The last change is to set the value of the CurrentCategory property I added to the ProductsListViewModel class. However, these changes mean that the value of PagingInfo.TotalItems is incorrectly calculated because it doesn't take the category filter into account. I will fix this in a while.

Unit Test: Updating Existing Unit Tests
I changed the signature of the List action method, which will prevent some of the existing unit test methods from compiling. To address this, I need to pass null as the first parameter to the LIst method in those unit tests that work with the controller. For example, in the Can_Paginate test in the ProductControllerTests.cs file, the action section of the unit test becomes as follow.
By using null for the category argument, I receive all the Product objects that the controller gets from the repository, which is the same situation I had before adding the new parameter. I need to make the same changes to the Can_Send_Pagination_View_Model test.
Keeping your unit tests synchronized with your code changes quickly becomes second nature when you get into the testing mind-set.
To see the effect of the category filtering, start the application and select a category using the following query string, changing the port to match the one that Visual Studio assigned for your project(and taking care to use an upper case S for Soccer):
You will see only the Products in the Soccer category.
Obviously, users won't want to navigate to categories using URLs, but you can see how small changes can have big impact in an MVC application once the basic structure is in place.

Unit Test: Category Filtering
I need a unit test to properly test the category filtering function to ensure that the filter can correctly generate products in a specified category. Here is the test method I added to the ProductControllerTests tests.
This test creates a mock repository containig Product objects that belong to a range of categories. Once specific category is requested using the action method, and the results are checked to ensure that the result are the right objects in the right order.

Refining the URL Scheme
No one wants to see or use ugly URLs such as /?category=Soccer. To address this, I am going to change the routing configuration in the Configure method of the Startup class to create a more useful set of URLs.
Caution: It is important to add the new routes in the specific order. Routes are applied in the order in which they are defined, and you will get some odd effects if you change the order.
The ASP.NET Core routing system is used by MVC to handle incoming requests from clients, but it also generates outgoing URLs that conform to the URL scheme and that can be embedded in web pages. By using the routing system both to handle incoming requests and to generate outgoing URLs, I can ensure that all the URLs in the application are consistent.
The IUrlHelper interface provides access to the URL-generating functionality. I used this interface and the Action method it defined in the tag helper I created in the previous chapter. Now that I want to start generating more complex URLs, I need a way to receive additional information from the view without having to add extra properties to the tag helper class. Fortunately, tag helpers have a nice feature that allows properties with a common prefix to be received altogether in a single collection. 
Decorating a tag helper property with the HtmlAttributeName attribute allows me to specify a prefix for attribute names on the ellement, which in this case will be page-url- The vaalue of any attribute whose name begins with this prefix will be added to the dictionary that is assigned to the PageUrlValues property, which is then passed to the IUrlHelper.Action method to generate the URL for the href attribute of the a elements that the tag helper produces.
We then have to add a new attribute to the div element that is processed by the tag helper, specifying the category that will be used to generate the URL. I have added only one new attribute to the view, but any attribute with the same prefix would be added to the dictionary.
Prior to this change, the links generated for pagination links we wrong.
If the user clicked a page link like this, the category filter would be lost, and the application would present a page containing the products from all categories. By adding the current category, taken from the view model, I generate better URLs.
When the user clicks such kind of links, the current category will be passed to the List action method, and the filtering will be preserved. After you have made this change, you can visit a URL such as /chess or /soccer and you will see that the link at the bottom of the page correctly includes the category.

Building a Category Navigation Menu
I need to provide customers with a way to select a category that does not involve typing in URLs. This means presenting them with a list of the categories available and indicating which, if any, is currently selected. As I build out the application, I will use this list of categories in more than one controller, so I need something that is self contained and reusable.
ASP.NET Core MVC has the concept of view component, which is perfect for creating items such as a reusable navigation control. A view component is a C# class that provides a small amount of reusable application logic with the ability to select and display Razor partial views. I describe view components later in details.
In this case, I will create a view component that renders the navigation menu and intergrates it into the application by invoking the component from the shared layout. This approach gives me a regular C# class that can contain whatever application logic I need and that can be unit tested like any other class. It is a nice way of creating small segments of an application while preserving the overall MVC approach.

Creating the Navigation View Component
I created a folder called components, which is the conventional home of view components, and added to it a class called NavigationMenuViewComponentt.cs, which I used to define a class.
The view component's Invoke method is called when the component is used in a Razor view, and the result of the invoke method is inserted into the HTML sent to the browser. I have started with a simple view component that returns a string, but I'll replace this with dynamic HTML content shortly.
I want the category list to appear on all pages, so I am going to use the view component in the shared layout rather than in a specific view. Within a view, view components are used through the @await Component.InvokeAsync expression.
I removed the placeholder text and replaced it with a call to the Component.InvokeAsync method. The argument to this method is the name of the componnet class, omiting the ViewComponent part of the class name, such that NavigationMenu specifies the NavigationMenuViewComponent class. If you run the application, you will see that the output from the Invoke method is included in the HTML sent to the browser.

Generating Category List
I can now return to the navigation view controller and generate a real set of categories. I could build the HTML for the categories programmatically, as I did for the page tag helper, but one of the benefits of working with view components is they can render Razor partial views. That means I can use the view component to generate the list of components and then use the more expressive Razor syntax to render the HTML that will display them. The first step is to update the view component.
The constructor defined defines an IProductRepository argument. When MVC needs to create an instance of the view component class, it will note the need to provide this argument and inspect the configuration in the Startup class to determine which implementation object should be used. This is the same dependency injection feature we talked about earlier and it has the same effect, which is to allow the view component to access data without knowing which repository implementation will be used.
In the Invoke method, I use LINQ to select and order the set of categories in the repository and pass them as the arguments to the View method, which render the default Razor partial view, details of which are returned from the method using an IViewComponentResult object, a process described later in more details.

Unit Test: Generating the Category List
The unit test for my ability to produce a category list is relatively simple. The goal is to create a list that is sorted in aplhabetical order and contains no duplicates, and the simplest way to do this is to supply some test data that does have duplicate categories and that is not in order, pass this to the tag helper class, and assert that the data has been properly cleaned up. Here is the unit test, which I defined in a new class file called NavigationMenuViewComponentTests.cs in the SportsStore.Tests project.
I created a mock repository implementation that contains repeating categories and categories that are not in order. I assert that the duplicates are removed and that alphabetical ordering is imposed.

Creating the View
Razor uses different conventions for dealing with views that are selected by view components. Both the default name of the view and the locations that are searched for the view are different from those used for controllers. To that end, I created the Views/Shared/Components/NavigationMenu folder and added to it a view file called Default.cshtml to which I added the view content.
This view uses one of the built-in tag helpers, which we'll describe later, to create elements whose href attribute contains a URL that selects a different product category.
You can see the category links if you run the application. If you click a category, the list of items is updated to show only items from the selected category.

Highlighting the Current Category
There is no feedback to the user to indicate which category has been selected. It might be possible to infer the category from the items on the list, but some clear visual feedback seems like a good idea. ASP.NET Core MVC components such as controllers and view components can receive information about the current request by asking for a context object. Most of the time, you can rely on the base classes that you use to create components to take care of getting the context object for you, such as when you use the Controller base class to create controllers.
The ViewComponent base class is no exception and provides access to context objects through a set of properties. One of the properties is called RouteData, which provides information about how the request URL was handled by the routing system.
Let's use the RouteData property to access the request data in order to get the value for the currently selected category. I could pass the category to the view by creating another view model class (and that's what I would do in a real project), but for variety, I am going to use the view bag feature we introducted earlier.
Inside the Invoke method, I have dynamically assigned a SelectedCategory property to the ViewBag object and set its value to be the current category, which is obtained through the context object returned by the RouteData property. The ViewBag is a dynamic object that allows us to define new properties simply by assigning values to them.

Unit test: Reporting the Selected Category
I can test that the view component correctly adds details of the selected category by reading the value of the ViewBag property in a unit test, which is available through the ViewViewComponentResult class. 
This unit test provides the view component with routing data through the ViewComponentContext property, which is how view components receive all of their context data. The ViewComponentContext property provides access to view-specific context data through its ViewContext property, which in turns provides access to the routing informatio through its RouteData property. Most of the code in the unit test goes into creating the context objects that will provide the selected category in the same way that it would be presented when the application is running and the context data is provided by ASP.NET Core MVC.
Now that I am providing information aabout which category is selected, I can update the view selected by the view component to take advantage of this and vary the CSS classes used to style the links to make the one representing the current category distinct from the others. 
I have used a Razor expression within the class attribute to apply the btn-primary class to the element that represents the selected category and the btn-secondary class otherwise. These classes apply different bootstrap styles and makes the active buttons obvious.

Correcting the Page Count
I need to correct the page links so that they work correctly when a category is selected. Currently, the number of page links is determined by the total number of products in the repository and not the number of products in the selected category. This means that the customer can click the link for page 2 of the Chess category and end up with an empty page because there are not enough products to fill two pages.
I can fix this by updating the List action method in the Product controller so that the pagination information takes the categories into account.
If a category has been selected, I return the number of items in that category; if not, I return the total number of products. Now when I view a category, the links at the bottom of the page correctly reflact the number of products in the category.

Unit Test: Category-Specific Product Counts
Testing that I am able to generate the current product count for different categories is simple. I create a mock repository that contains known data in a range of categories and then call the List action method requesting each category in turn.
Notice that I also call the List method, specifying no category, to make sure I get the correct total count as well.

Building the Shopping Cart
The application is progressing nicely, but I cannot sell any products until I implement a shopping cart. In this section, I will create the shopping cart experience. This will be familiar to anyone who has ever made a purchase online.
An Add to Cart button will be displayed alongside each of the producct in the catalog. Clicking this button will show a summary of the products the customer has selected so far, including the total cost.  At this point, the user can click the Continue shopping button to return to the product catalog or click the checkout Now button to complete the order and finish the shopping session.

Defining the Cart Model
I started by adding a class file  called Cart.cs to the Models folder in and used it to define a class.
The Cart class uses the CartLine class, defined in the same file, to represent a product selected by the customer and the quantity the user wants to buy. I defined methods to add an item to the cart, remove a previously added item from the cart, calculate the total cost of the items in the cart, and reset the cart by removing all the items. I also provided a property that gives access to the contents of the cart using an IEnumerable<Cartline>. This is all straightforward stuff, easily implemented in the C# with the help of a litte LINQ. 

Unit Test: Testing The Cart
The Cart class is relatively simple, but it has a range of important behaviours that must work properly. A poorly functioning cart would undermine the entire SportsStore application. I have broken down the features and tested them individually. I created a new unit test file called CartTests.cs in the SportsStore.Tests project called to contain these tests. 
The first behaviour relates to when I add an item to the cart. If this is the first time that a given Product has been added to the cart, I want a new Cartline to be added. Here is the test, inluding a unit test class definition.
However, if the customer has already added a Product to the cart, I want to increment the quantity of the corresponding CartLIne and not create a new one. Here is the test:
I also need to check that users can change their mind and remove products from the cart. This feature is implemented by the RemoveLine method. Here is the test:
The next behaviour I want to test is the ability to calculate the total cost of the items in the cart. Here's the test for this behaviour:
The final test is simple. I want to ensure that the contents of the cart are properly removed when reset. Here is the test:
Sometimes, as in this case, the code required to test the functionality of a class is longer and more complex than the class itself. Do not let that put you off writing the unit tests. Defects in simple classes can have huge impacts, especially ones that play such an important role as Cart does in the example application.

Adding the Add to Cart Buttons
I need to edit the Views/Shared/ProductSummary.cshtml partial view to add the buttons to the product listing. To prepare for this, I added a class file called UrlExtensions.cs to the Infrastructure folder and defined to it an extension method.
The PathAndQuery extension method operates on the HttpRequest class, which ASP.NET uses to describe an HTTP request. The extension method generates a URL that the browser will be returned to after the cart has been updated, taking into account the query string if there is one. Below, I have added the namespace that contains the extension method to the view imports fiel so that I can use it in the partial view.
We then update the partial view that describes each product to contain an Add to Cart button.
I have added a form element that contains hidden input elements specifying the ProductID value from the view model and the URL that the browser should be returned to after the cart has been updated. The form element and one of the input elements are configured using built-in tag helpers, which are a useful way of generating forms that contain model values and that target controllers and actions in the application. The other input element uses the extension method I created to set the return URL. I also added a button element that will submit the form to the application.
Note: Notice that I have set the method attribute on the form element to post, which instructs the browsser to submit the form data using an HTTP POST request. You can change this so that forms use the GET method, but you should think carefully about doing so. The HTTP specification requires that GET requests must be idempontent, meaning that they must not cause changes, and adding a product to a cart is definitely a change. I have more to say on this topic later, including an explanation on what can happen if you ignore the need for idempotent GET requests.

Enabling Sessions
I am going to store details of a user's cart using session state, which is data that is stored at the server and associated with a series of requests made by a user. ASP.NET provides a range of different ways to store session state, including storing it in memory, which is the approach that I am going to use. This has the advantage of simplicity, but it means that the session data is lost when the application is stopped or restarted. Enabling sessions requires adding services and middleware in the Startup class. 
The AddMemoryCache method call sets up the in-memory data store. The AddSession method registers the services used to access session data, and the UseSession method allows the session system to automatically associate requests withs sessions when they arrive from the client.

Implementing the Cart Controller
I need a controller to handle the Add to Cart button presses. I added a new class file called CartController.cs to the controllers folder and used it to define a class.
There are a few points to note about this controller. The first is that I use the ASP.NET session state feature to store and retrieve Cart objects, which is the purpose of the GetCart method. The middleware that I registered earlier on uses cookies or URL rewriting to associate multiple requests from a user together to form a single browser session. A related feature is session state, which associates data with a session. This is an ideal fit for the cart class: I want each user to have their own cart, and I want the cart to be persistent between requests. Data associated with a session is deleted when a session expires (typically because a user has not made a request for a while), which means that I do not need to manage the storage or life cycle of the cart objects.
For the AddToCart and RemoveFromCart action methods, I have used parameter names that match the input elements in the HTML forms created in the ProductSummary.cshtml view. This allows MVC to associate incoming form POST variables with those parameters, meaning that I do not need to process the form myself. This is known as model binding and is a powerful tool for simplifying controller classes, we'll look at this later.

Defining Session State Extension Methods
The session state feature in ASP.NET Core stores only int, string and byte[] values. Since I want to store a Cart object, I need to define extension methods to the ISession interface, which provides access to the session state data to serialize Cart objects into JSON and convert them back. I added a class file called SessionExtensions.cs to the Infrastructure folder and defined the extensions method to it.
These methods rely on the Json.Net package to serialize objects into the JavaScript Object Notation format, which you encounter later. The Json.Net package doesnt' have to be added to the project because it is already used behind the scenes by MVC to provide the JSON helper features.
The extension methods make it wasy to store and retrieve Cart objects. To add a Cart to the session state in the controller.
The HttpContext property is provided by the Controller base class from which controllers are usually derived and returns an HttpContext object that provides context data about the request that has been received and the response that is prepared. The HttpContext.Session property returns an object that implements the ISession interface, which is the type on which I defined the SetJson method, which accepts arguments that specify a key and an object that will be added to the session state. The extension method serializes the object and adds it to the session state using the underlying functionality provided by the ISession state interface. To retrieve the cart again, I use the other extension method, specifying the same key. 
The type parameter lets me specify the type that I expect to be retrieved, which is used in the deserialization process.

Displaying the Content of the Cart
The final point to note about the Cart controller is that both the AddToCart and RemoveFromCart methods call the RedirectToAction method. This has the effect of sending an HTTP redirect instruction to the client browser, asking the browser to request a new URL. In this case, I have asked the browser to request a URL that will call the Index action method of the Cart controller
I am going to implement the Index method and use it to display the contents of the Cart. If you refer back, you will see that this is the workflow when the user clicks the Add to Cart button.
I need to pass two pieces of information to the view that will display the contents of the cart: the Cart object and the URL to display if the user clicks the Continue Shopping button. I create a new class file called CartIndexViewModel.cs in the Models/viewModels folder of the SportsStore project and used it to define a class.
Now I have the view model, I can implement the Index antion method in the Cart controller class.
The Index action, retrieves the Cart object fom the session state and uses it to create a CartIndexViewModel object, which is then passed to the View method to be used as the View model.
The last step to display the contents of the cart is to create the view that the Index action will render. I created the Views/Cart folder and added to it a Razor view file called Index.cshtml with some markup.
The view enumerates the lines in the cart and adds rows for each of them to an HTML table, along with the total cost per line and the total cost for the cart. The classes to which I assigned the elements correspond to Bootstrap styles for tables and text-alignment..
The result is that the basic functions of the shopping cart are in place. First products are listing along with a button to add them to the cart
Second, when the user clicks the Add to Cart button, the appropriate product is added to their cart, and a summary of the cart is diplayed. Clicking the Continue Shopping button returns the user to the product page they came from.

Summary
In this chapter, I started to flesh out the customer facing parts of the SportsStore app. I provided the means by which the user can navigate by category and put the basic building blocks in place for adding items to a shopping cart. I have more work to do, and I continue the development of the application in the next chapter.