Chapter 9: Navigation
In this chapter, I continue to build out the SportsStore example app. In this chapter, I add support for navigating around the application and start building the shopping cart.

Adding Navigation Controls
The SportsStore application will be more useful if customers can navigate products by category. I will do this in three phases.
- Enhance the List action model in the ProductController class so that it is able to filter the Product objects in the repository.
- Revist and enhance the URL scheme
- Create a category list that will go into the sidebar of the site, highlighting the current category and linking to others

Filtering the Product List
I am going to start by enhancing the view model class, ProductsListViewModel, which I added to the SportsStore project in the previous chapter. I need to communicate the current category to the view in order to render the sidebar, and this is a good place to start as any. 
I added a property called CurrentCategory. The next step is to update the ProductController so that the List action method will filter Product objects by category and use the new property I added to the view model to indicate which category has been selected.
I made three changes to the action method. First, I added a parameter called category. This category parameter is used by the second change in the listing, which is an enhancement to the LINQ query: if category is not null, only those Product objects with a matching Category property are selected. The last change is to set the value of the CurrentCategory property I added to the ProductsListViewModel class. However, these changes mean that the value of PagingInfo.TotalItems is incorrectly calculated because it doesn't take the category filter into account. I will fix this in a while.

Unit Test: Updating Existing Unit Tests
I changed the signature of the List action method, which will prevent some of the existing unit test methods from compiling. To address this, I need to pass null as the first parameter to the LIst method in those unit tests that work with the controller. For example, in the Can_Paginate test in the ProductControllerTests.cs file, the action section of the unit test becomes as follow.
By using null for the category argument, I receive all the Product objects that the controller gets from the repository, which is the same situation I had before adding the new parameter. I need to make the same changes to the Can_Send_Pagination_View_Model test.
Keeping your unit tests synchronized with your code changes quickly becomes second nature when you get into the testing mind-set.
To see the effect of the category filtering, start the application and select a category using the following query string, changing the port to match the one that Visual Studio assigned for your project(and taking care to use an upper case S for Soccer):
You will see only the Products in the Soccer category.
Obviously, users won't want to navigate to categories using URLs, but you can see how small changes can have big impact in an MVC application once the basic structure is in place.

Unit Test: Category Filtering
I need a unit test to properly test the category filtering function to ensure that the filter can correctly generate products in a specified category. Here is the test method I added to the ProductControllerTests tests.
This test creates a mock repository containig Product objects that belong to a range of categories. Once specific category is requested using the action method, and the results are checked to ensure that the result are the right objects in the right order.

Refining the URL Scheme
No one wants to see or use ugly URLs such as /?category=Soccer. To address this, I am going to change the routing configuration in the Configure method of the Startup class to create a more useful set of URLs.
Caution: It is important to add the new routes in the specific order. Routes are applied in the order in which they are defined, and you will get some odd effects if you change the order.
The ASP.NET Core routing system is used by MVC to handle incoming requests from clients, but it also generates outgoing URLs that conform to the URL scheme and that can be embedded in web pages. By using the routing system both to handle incoming requests and to generate outgoing URLs, I can ensure that all the URLs in the application are consistent.
The IUrlHelper interface provides access to the URL-generating functionality. I used this interface and the Action method it defined in the tag helper I created in the previous chapter. Now that I want to start generating more complex URLs, I need a way to receive additional information from the view without having to add extra properties to the tag helper class. Fortunately, tag helpers have a nice feature that allows properties with a common prefix to be received altogether in a single collection. 
Decorating a tag helper property with the HtmlAttributeName attribute allows me to specify a prefix for attribute names on the element, which in this case will be page-url- The vaalue of any attribute whose name begins with this prefix will be added to the dictionary that is assigned to the PageUrlValues property, which is then passed to the IUrlHelper.Action method to generate the URL for the href attribute of the a elements that the tag helper produces.
We then have to add a new attribute to the div element that is processed by the tag helper, specifying the category that will be used to generate the URL. I have added only one new attribute to the view, but any attribute with the same prefix would be added to the dictionary.
Prior to this change, the links generated for pagination links we wrong.
If the user clicked a page link like this, the category filter would be lost, and the application would present a page containing the products from all categories. By adding the current category, taken from the view model, I generate better URLs.
When the user clicks such kind of links, the current category will be passed to the List action method, and the filtering will be preserved. After you have made this change, you can visit a URL such as /chess or /soccer and you will see that the link at the bottom of the page correctly includes the category.

Building a Category Navigation Menu